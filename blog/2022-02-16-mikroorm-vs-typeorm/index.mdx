---
title: "MikroORM 과 TypeORM 비교"
authors: jake
tags: [mikroorm, typeorm]
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

이번 글은 ts 환경에서 주로 사용되는 ORM 인 `TypeORM` 를 사용하면서 발생한 문제점을 소개하고 또 다른 ORM 인 `MikroORM` 에서 어떻게 해결하고 있는지에 대한 내용을 담고있다.

<!--truncate-->

## TypeORM

TypeORM 은 `JavaScript` 와 `TypeScript` 환경에서 사용하는 ORM (Object–relational mapping) 이다.
주로 ts 진영에서 많이 사용하며 `Active Record` 와 `Data Mapper` 패턴을 지원한다.

처음 이 라이브러리를 발견했을 때에는 굉장히 마음에 들었지만 실무에서 계속 사용해보니 이름에 비해 생각만큼 typesafe 하지 않다고 느꼈으며 여러 이슈를 자주 겪었다.
특히 이 라이브러리는 아직도 첫 major 버전이 나오지 않았을 정도로 업데이트가 더딘 상황이다.
하지만 `TypeORM` 외에 더 나은 대안이 없는 상황이라 계속 사용하고 있었다.

## MikroORM

`MikroORM` 은 오랜기간 PHP 개발자였던 [Martin Adámek](https://github.com/B4nan) 가 Node.js 로 넘어오면서 만든 ORM 라이브러리다.
넘어오면서 `TypeORM` 을 써봤는데 실망을 느껴 직접 만들었다고 한다.

> 이와 관련된 글은 [링크](https://medium.com/dailyjs/introducing-mikro-orm-typescript-data-mapper-orm-with-identity-map-9ba58d049e02) 에서 확인할 수 있다.

`MikroOMR` 은 `Data Mapper`, `Unit of Work` 와 `Identity Map` 패턴을 지원한다.
공식문서를 살펴보고 직접 예제를 만들어 보면서 느낀점은 `TypeORM` 에서 제대로 동작하지 않았던 문제가 깔끔하게 해결되며 훨씬 typesafe 하다는 것이었다.

이제 두 라이브러리를 기능과 타입안정성 측면에서 비교해보자.

:::info
이후 나오는 코드 `Nest.js` 환경에서 `Data Mapper` 패턴을 사용한 예제이며 전체 코드는 [링크](https://github.com/jbl428/study-note/tree/master/nodejs/orm) 를 참조한다.
:::

## Entity 정의 방식

두 라이브러리 모두 클래스와 프로퍼티에 데코레이터를 추가해 엔티티를 정의한다.
`MikroORM` 는 추가로 `EntitySchema` 라는 방식을 지원하며 스키마를 프로그래밍 하듯이 생성할 수 있다.
이번 글에서는 주로 사용하는 데코레이터 방식을 사용할 것이다.

컬럼의 타입정보와 데코레이터의 메타데이터 정보를 얻기 위해 두 라이브러리 모두 `reflect-metadata` 를 사용한다.
하지만 `MikroORM` 은 `ts-morph` 를 사용하는 방식을 추가로 지원하며 이를 사용하면 엔티티 선언이 더 간결해진다.

예제로 만들 엔티티는 `Post` 와 `Comment` 로 하나의 포스트에 여러 댓글이 존재하는 1:N 관계이다.
먼저 `TypeORM` 의 경우 아래와 같이 선언한다.

<Tabs groupId="orm">
  <TabItem value="post" label="post.entity.ts" default>

```ts
@Entity()
export class Post extends BaseEntity {
  @Column()
  name: string;

  @Column()
  content: string;

  @Column({ type: "varchar", length: 10, transformer: new PostStatusType() })
  status: PostStatus;

  @Column({ nullable: true })
  memo?: string;

  @OneToMany(() => Comment, (comment) => comment.post, {
    cascade: ["insert", "update"],
  })
  comments: Comment[];
}
```

  </TabItem>
  <TabItem value="comment" label="comment.entity.ts">

```ts
@Entity()
export class Comment extends BaseEntity {
  @Column()
  content: string;

  @Column()
  like: number;

  @Column({ nullable: true })
  memo?: string;

  @ManyToOne(() => Post, (post) => post.comments, {
    createForeignKeyConstraints: false,
    nullable: false,
  })
  @Index()
  @JoinColumn({ name: "post_id", referencedColumnName: "id" })
  post: Post;
}
```

  </TabItem>
</Tabs>

`MikroORM` 은 다음과 같이 선언한다.

<Tabs groupId="orm">
  <TabItem value="post" label="post.entity.ts" default>

```ts
@Entity()
export class Post extends BaseEntity {
  @Property()
  name: string;

  @Property()
  content: string;

  @Property({ type: PostStatusType })
  status: PostStatus;

  @Property()
  memo?: string;

  @OneToMany(() => Comment, (comment) => comment.post)
  comments = new Collection<Comment>(this);
}
```

  </TabItem>
  <TabItem value="comment" label="comment.entity.ts">

```ts
@Entity()
export class Comment extends BaseEntity {
  @Property()
  content: string;

  @Property()
  like: number;

  @Property()
  memo?: string;

  @ManyToOne()
  post: IdentifiedReference<Post>;
}
```

  </TabItem>
</Tabs>

두 라이브러리 간의 차이점을 살펴보자

### 필드의 NULL 선언

원하는 필드를 `NULL` 로 설정하려면 `TypeORM` 에서는 데코레이터에 직접 `nullable` 값을 true 로 설정해야 한다.
하지만 `MikroOMR` 에서는 프로터티 타입을 nullable 로 선언하기만 하면 된다.
이는 더 간결할 뿐만아니라 ts 타입과 실제 컬럼의 타입의 동일함을 보장해준다.

그동안 데코레이터에는 `nullable` 로 선언했지만 ts 타입을 required 로 선언하는 실수가 자주 발생했다.
이로인해 `Optional Chaining` 사용하지 않고 프로터피를 참조하다가 런타임 에러가 발생하는 경우가 많았다.
ts 의 `strictNullCheck` 옵션을 활성화하면 nullable 타입을 참조하기 전에 null 체크를 필수로 해야하기에 더 안전한 개발이 가능하다.

### FK 해제

### 연관관계 설정
