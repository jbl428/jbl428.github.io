---
title: "배달비 노노 프로젝트을 진행하며"
authors: jake
tags: [hexagonal, fp-ts, prisma]
---

사이드 프로젝트로 진행하고 있는 [배달비 노노 백엔드 서버](https://github.com/bae-no/bae-no-server)에 대한 소개와 기술적인 고민에 대한 내용을 담았다.

<!--truncate-->

## 프로젝트 소개

배달비 노노 프로젝트는 이름 그대로 주문 음식의 배달비를 줄일 수 있는 기회를 제공해준다.  
근처에 있는 사람들끼리 모여 같이 주문한 후 배달비를 나눠서 지불하는 방식이다.

애플리케이션 형태로 제공하며 사용자는 본인 주변에 있는 공유딜을 찾아 참여한 후 채팅을 통해 서로 소통하여 주문 및 정산을 진행한다.  
간단히 말해, 짧은 주기를 가지는 채팅방 어플리케이션이라고 볼 수 있다.

![share-deal](share-deal.jpg)
![chat-room](chat-room.jpg)

## 개발 스택

백엔드 서버의 개발 스택은 다음과 같이 이루어져 있다.

- Nest.JS
- GraphQL
- MongoDB
- Prisma

Nest.js에서 주로 REST로만 개발을 진행해봐서 이번에 GraphQL을 사용해보고 싶었다.  
MongoDB는 회사에서 검색엔진으로 사용하면서 처음 사용해보았는데 그 경험이 좋았고 채팅방 이력을 저장하기 좋은 구조라고 생각해 선택하였다.  
Prisma도 이번에 처음 사용해보았고 예전부터 사용해온 TypeORM, MikroORM과 비교해 어떤점이 좋을지 경험하고자 선택하였다.

## 프로젝트 구조

업무에서 계속 사용해온 계층형 아키텍쳐대신 헥사고날 아키텍쳐라고 불리는 포트와 어댑터 패턴을 사용했다.  
전체적인 디렉토리 구조는 [만들면서 배우는 클린 아키텍처](http://www.yes24.com/Product/Goods/105138479)를 참고해서 만들었다.  
파일명도 일반적인 Nest.js컨벤션 대신 JVM에서 많이 사용하는 패턴을 사용했다.

```
sample
├── SampleModule.ts
├── adapter
│   ├── in
│   │   └── gql
│   │       ├── SampleMutationResolver.ts
│   │       ├── SampleQueryResolver.ts
│   │       ├── SampleSubscriptionResolver.ts
│   │       ├── input
│   │       │   └── CreateSampleInput.ts
│   │       └── response
│   │           └── SampleResponse.ts
│   └── out
│       └── persistence
│           ├── SampleOrmMapper.ts
│           ├── SampleQueryRepositoryAdapter.ts
│           └── SampleRepositoryAdapter.ts
├── application
│   ├── port
│   │   ├── in
│   │   │   ├── SampleCommandUseCase.ts
│   │   │   ├── SampleQueryUseCase.ts
│   │   │   └── dto
│   │   │       └── CreateSampleCommand.ts
│   │   └── out
│   │       ├── SampleQueryRepositoryPort.ts
│   │       └── SampleRepositoryPort.ts
│   └── service
│       ├── SampleCommandService.ts
│       └── SampleQueryService.ts
└── domain
    └── Sample.ts
```

src 디렉토리 아래에 모듈별로 디렉토리를 만들고 그 안에 위와 같은 구조로 파일을 만들었다.  
모듈 안에는 크게 domain, application, adapter로 나누었고 각각 다음과 관련된 로직이 들어있다.

- domain: 도메인 모델과 비즈니스 로직
- application: 도메인 모델을 사용하는 비즈니스 로직
- adapter: GraphQL, Notification, DB등 인프라와 관련된 로직

시간이 지나면 언제든지 변경될 수 있는 요소는 adapter에 모아두고, 도메인과 비즈니스 로직은 application과 domain에 위치한다.  
application에는 외부에서 사용할 `inbound port`인터페이스와 Service에서 사용하는 `outbound port`인터페이스가 있다.  
adatper는 `outbound port`를 구현하고 `inbound port`를 사용해 GraphQL과 같은 api요청과 응답로직을 구현한다.  
domain은 모두 순수한 클래스만 가지고 있으며 핵심적인 비즈니스 로직만을 가지고 있다.

![dir-structure](dir-structure.jpg)

## fp-ts

[fp-ts](https://gcanti.github.io/fp-ts/)는 대수적 자료형을 제공하는 라이브러리로 `Option`, `Task`, `Either` 등의 유용한 타입을 제공한다.  
예전부터 여러 프로그래밍 패러다임을 같이 사용해보고 싶었고 어떤 장단점이 있을지 궁금했다.

이전 `santa-close`프로젝트에서 `spring + kotlin arrow`를 사용했지만 제대로 활용하지 못했다.  
이번에는 대부분의 메소드 내부구현은 `fp-ts`를 활용해 순수 메소드로 만들고, 실제 응답값을 반환해야 하는 resolver에서만 사이드 이펙트가 발생하도록 만들었다.  
대부분의 메소드가 비동기 로직을 담고있고 에러가 발생할 수 있기에 `TaskEither`를 주로 사용했다.

각 패러다임을 활용하는 부분은 다음과 같다.

- OOP: 의존성 주입, 상태와 행위의 결합
- FP: 에러처리, 병렬처리, 부작용 제거

## 느낀점 및 고민

프로젝트를 진행하면서 느낀점과 고민을 정리해보았다.

### fp-ts

`fp-ts`는 외부 라이브러리이기에 어느 영역까지 사용을 허용할지 고민이 많았다.  
예를들어 도메인 클래스의 유효성 검증 메소드를 생각해보자.  
검증에 실패하면 일반적인 경우에는 다음과 같은 도메인 에러를 던지는 코드를 작성할 것이다.

```typescript
class PhoneVerification {
  // ...생략
  verify(code: string, now = new Date()): void {
    if (this.code !== code) {
      throw new MismatchedCodeException()
    }

    if (this.isExpired(now)) {
      throw new ExpiredCodeException()
    }
  }
}
```

위 메소드를 사용하는 곳은 서비스 영역인데 순수메소드 형태를 유지하기 위해 `tryCatch`를 사용해 `Either`로 만들어야 하는 불편함이 존재한다.  
또한 메소드의 구현부를 읽어야만 해당 메소드가 어떤 에러를 던지는지 파악할 수 있다는 단점이 있다.

하지만 도메인 클래스 내부에서 `Either`를 반환하게 만들면 `fp-ts`라는 외부 라이브러리에 대한 의존성이 생기므로 가장 순수해야 할 영역이 오염된다.  
물론 `Either`와 같은 대수적 자료형은 직접 클래스 형태로 구현할 수 있지만 `Higher Kinded Type`을 구현하기 어려워 `map`, `chain`함수의 타입추론이 까다로워진다.

```typescript
// 외부 의존성
import { Either, left, right } from 'fp-ts/Either';

class PhoneVerification {
  // ...생략
  verify(
    code: string,
    now = new Date(),
  ): Either<ExpiredCodeException | MismatchedCodeException, void> {
    if (this.code !== code) {
      return left(new MismatchedCodeException());
    }

    if (this.isExpired(now)) {
      return left(new ExpiredCodeException());
    }

    return right(undefined);
  }
}
```

`Haskell`과 같은 순수 함수형 언어에서는 `Either`와 같은 대수적 자료형을 기본제공하기에 도메인 내부에서 사용하는데 문제가 없다.  
그래서 `fp-ts`의 자료형들을 **node.js의 확장된 내장타입**으로 생각하고 사용하기로 했다.  
물론 외부 라이브러리이기에 미래에 언제든지 교체될 수 있는 가능성이 있지만, Node의 **String, Number, Boolean과 같은 교체되기 힘든 타입과 같은 영역**을 다루기에 사용해도 괜찮다는 생각이 들었다.

### 모니터링과 로깅

`fp-ts`를 사용하는 경우 모니터링과 로깅에 신경써야 하는 부분이 있다.  
보통 데이터베이스 조회와 같은 비동기 로직은 사이드 이팩트를 발생하므로 `TaskEither`를 사용하게된다.  
`TaskEither`는 promise를 사용하는 로직에 대한 추상화로 아직 어떠한 값을 가지고 있지 않는다.

보통 `TaskEither`를 반환하는 함수들을 합성해 최종적으로 하나의 함수를 만들며 이 함수를 실행할 때 비동기 로직이 실행된다.  
따라서 `TaskEither`를 반환하는 메소드의 실행시간을 측정하면 **함수의 합성에 걸리는 시간만 포함하지 실제 비동기 로직에 대한 시간은 포함하지 않는다**.

예를들어 datadog을 모니터링에 사용하는 경우 아래 코드처럼 span을 생성해 실행시간을 측정해보면 데이터베이스 상태와 관계없이 매우 짧은 일정한 시간을 가진다.

```typescript
import tracer from 'dd-trace';

class ChatQueryRepositoryAdapter {
  override unreadCount(
    shareDealId: string,
    userId: string,
  ): TaskEither<DBError, number> {
    return tracer.trace('ChatQueryRepositoryAdapter.unreadCount', () =>
      pipe(
        tryCatchDB(() =>
          this.prisma.chat.count({
            where: {
              shareDealId,
              userId,
              message: { is: { unread: true } },
            },
          }),
        ),
      ),
    );
  }
}
```

또한 에러가 발생할 때 해당 에러객체에 대한 로그를 출력할 때 스택트레이스가 제대로 나오지 않는 문제가 있다.  
에러 인스턴스가 생성된 시점의 스택은 나오지만 생성 전까지 호출한 함수의 스택은 나오지 않는다.  
이는 `Error.captureStackTrace`을 사용하는 것으로 해결할 수 있다.

```typescript
export abstract class BaseException extends Error {
  protected constructor(message: string) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
  }
}
```

위 클래스를 상속받아 도메인 에러클래스를 만들어 사용하면 된다.

[//]: # (### 의존성 주입)

[//]: # ()
[//]: # (Nest.js에서는 의존성 주입을 원하는 클래스에 `@Injectable`데코레이터를 사용해야 한다.)

[//]: # ()
[//]: # (- Nest.js의존성 제거)

[//]: # (- @Inject는 잘못 지정할 가능성이 있다.)

[//]: # (- 번거로움)

[//]: # ()
[//]: # (### prisma)

[//]: # ()
[//]: # (- 도메인 클래스와 orm클래스 두 번 만들지 않아도 된다.)

[//]: # (- graphql과 연결이 없어서 생산성 측면에서는 좋지않다.)

[//]: # (- 지도 관련 기능이 부족하다.)

[//]: # ()
