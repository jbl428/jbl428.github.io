---
title: "Kotlin + Spring GraphQL + Spring Security 사용하기"
authors: jake
tags: [string, graphql, security, jwt]
---

이번 포스트에서는 `Spring for GraphQL` 프로젝트가 GA 되어 샘플 프로젝트를 만드는 과정을 기술하려고 한다.  
다음과 같은 기술을 사용해서 구현하였다.

- [Kotlin](https://kotlinlang.org)
- [Spring Boot (WebFlux)](https://spring.io/projects/spring-boot)
- [Spring GraphQL](https://spring.io/projects/spring-graphql)
- [Spring Security](https://spring.io/projects/spring-security)
- [Spring Data MongoDB (Reactive)](https://spring.io/projects/spring-data-mongodb)
- [Gradle](https://gradle.org)

> 샘플 프로젝트 코드는 [github](https://github.com/jbl428/study-note/tree/master/kotlin/spring-graphql) 에서 볼 수 있다.

<!--truncate-->

## 초기 프로젝트 세팅

[Spring Initializr](https://start.spring.io) 에 접속해서 초기 스프링 프로젝트 세팅을 시작한다.  
`Gradle Project` 를 선택하고 Language 는 `Kotlin` 을 선택한다.  
의존성은 아래 화면에 보이는 것을 선택하면 된다.

![spring-initializr](spring-initializr.png)

## MongoDB 설정

보통 스프링 프로젝트에서 [Spring Data JPA](https://spring.io/projects/spring-data-jpa) 를 활용하는 예제가 많다.  
하지만 코틀린에서는 엔티티 선언시 `data class` 를 사용하지 못하고 필드를 `var` 로 선언해야 하는 등 여러 문제가 있다.  
그래서 이번에는 코틀린을 잘 지원하는 `Spring Data MongoDB` 를 사용하며 reactive 기반의 프로젝트를 만들어보려고 한다.

먼저 docker-compose.yml 파일을 생성해 아래와 같은 내용을 넣어준다.

```yaml title="docker-compose.yml"
services:
  mongo:
    image: mongo:5.0.6
    restart: always
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_DATABASE: test
      MONGO_INITDB_ROOT_USERNAME: test
      MONGO_INITDB_ROOT_PASSWORD: test
```

이제 `docker-compose up` 명령어를 실행하면 27017 포트에 MongoDB 서버가 실행된다.  
프로젝트 환경변수 파일을 통해 디비 접속정보를 넣어준다.

```yaml title="src/main/resources/application.yml"
spring:
  data:
    mongodb:
      host: localhost
      port: 27017
      database: test
      username: test
      password: test
      authentication-database: admin
```

테스트 코드에서는 실제 해당 서버를 사용하지 않고 `Embedded MongoDB` 데이터베이스를 사용할 수 있다.  
아래와 같이 version 에 원하는 버전을 넣어주면 해당버전으로 동작하는 내장 데이터베이스를 사용한다.

:::info
위와 같은 내장 데이터베이스로 하는 테스트가 실제 서버에서 하는 테스트를 완전히 대체할 수 없다.  
Embedded 에서 특정 기능이 제대로 지원하지 않는 경우나 더 엄격한 테스트를 원한다면 실제 디비서버로 테스트 해야한다.
:::

```yaml title="src/test/resources/application.yml"
spring:
  mongodb:
    embedded:
      version: '5.0.6'
```

## Repository

단순한 예제를 위해 `Book` document 를 의미하는 클래스를 생성한다.  
JPA 와 달리 `data class` 로 선언할 수 있으며 필요한 annotation 개수도 적다.

```kt title="Book.kt"
data class Book(
    val title: String,
    val author: String,
    val isbn: String,
    val publishers: List<Publisher> = emptyList(),
    val info: Info? = null
) {
    // 이 필드는 _id 를 의미하며 insert 시 자동 할당되므로 lateinit 으로 선언했다
    @Id
    lateinit var id: String
}

data class Publisher(
    val name: String,
    val email: String,
)

data class Info(
    val preface: String,
)
```

기본적인 CRUD 를 담당할 repository 를 생성한다.

```kt title="BookRepository.kt"
import org.springframework.data.mongodb.repository.ReactiveMongoRepository

interface BookRepository : ReactiveMongoRepository<Book, String>
```

## Service

이번 예제에서는 `Book` 를 생성하고 조회하는 로직만 구현하려고 한다.  
`BookService` 는 `BookRepository` 를 이용하여 `Book` 를 생성하고 조회한다.  
Kotlin 의 suspend 함수와 `kotlinx-coroutines-reactor` 패키지에서 제공하는 확장함수를 활용하면 기존 reactive 기반에서 사용하는 `Mono`, `Flux` 사용을 대체할 수 있다.

```kt title="BookService.kt"
@Service
class BookService(private val bookRepository: BookRepository) {

    // java 를 사용했다면 이 메소드는 Flux<Book> 을 반환할 것이다
    suspend fun find(): List<Book> =
        bookRepository
            .findAll()     // reactive 기반에서는 Flux 를 반환한다
            .collectList() // Flux 를 Mono 로 만들어주는 메소드
            .awaitSingle() // 이 확장함수 덕분에 반환값은 List<Book> 이 될 수 있다

    // Book 을 생성하고 반환한다 id 필드는 자동으로 설정된다
    suspend fun create(input: CreateBookInput): Book =
        Book(
            title = input.title,
            author = input.author,
            isbn = input.isbn,
        ).run {
            bookRepository.save(this)
        }.awaitSingle()
}
```

위 서비스 로직을 `Embedded MongoDb` 를 활용해 테스트 코드를 작성해보자.  
테스트 프레임워크는 `Junit` 대신 코틀린 dsl 을 활용하는 `kotest` 를 사용했다.  
junit 에서는 suspend 함수를 테스트하려면 `runBlocking` 함수를 사용해야 하는 등 번거로운 작업이 필요한지만 kotest 는 test scope 자체가 suspend 함수를 지원하기에 더 간결한 코드를 작성할 수 있다.

먼저 다음 패키지를 설치해야 한다.

```kts title="build.gradle.kts"
dependencies {
    testImplementation("io.kotest:kotest-runner-junit5:5.3.0")
    testImplementation("io.kotest.extensions:kotest-extensions-spring:1.1.1")
}
```

다음은 kotest 에서 제공하는 여러 spec 중 `FreeSpec` 을 활용한 테스트 코드이다.

```kt title="BookServiceTest.kt"
@DataMongoTest
internal class BookServiceTest(
    private val bookRepository: BookRepository,
) : FreeSpec({
    val bookService = BookService(bookRepository)

    beforeSpec {
        // 각 테스트 케이스간의 독립성을 위해 book 컬렉션의 데이터를 모두 삭제한다
        // block 을 사용해 삭제 작업이 끝날때까지 기다린다
        // 만약 awaitSingle 을 사용하면 아직 삭제가 완료되지 않았는데도 테스트를 실행할 수 있으므로 주의
        bookRepository.deleteAll().block()
    }

    "find" {
        // given
        val book = Book(
            title = "The Lord of the Rings",
            author = "J.R.R. Tolkien",
            isbn = "0-395-07477-1",
        )
        // awaitSingle 확장함수는 suspend 함수에서만 호출할 수 있다
        bookRepository.save(book).awaitSingle()

        // when
        val foundBook = bookService.find()

        // then
        foundBook shouldBe listOf(book)
    }

    "create" {
        // given
        val input = CreateBookInput(
            title = "The Lord of the Rings",
            author = "J.R.R. Tolkien",
            isbn = "0-395-07477-1",
        )

        // when
        val result = bookService.create(input)

        // then
        assertSoftly(result) {
            title shouldBe input.title
            author shouldBe input.author
            isbn shouldBe input.isbn
        }
    }
})
```

## Controller

작성중

## Security

작성중
