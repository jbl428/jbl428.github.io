---
title: "Effect-ts로 테스트 가능하고 효율적인 코드 작성하기"
description: 부작용을 효율적으로 다루기 위한 라이브러리인 Effect-ts의 메인테이너의 발표영상을 요약하였다.
authors: jake
draft: true
tags: [effect-ts, fp-ts]
---

대수적 자료형을 제공하는 Typescript 라이브러리인 fp-ts의 메인테이너 [Giulio Canti](https://github.com/gcanti)의 최근 활동을 보면 [fp-ts](https://github.com/fp-ts)그룹 내의 저장소에 작업을 하는것을 볼 수 있다.

![gcanti-profile](./gcanti-profile.png)

그 중에서 [core](https://github.com/fp-ts/core) 저장소를 보면 해당 프로젝트의 목적이 `@effect` 생태계와의 통합을 위한 것이라고 한다.  
core 라이브러리는 대수적 자료형을 위한 인터페이스와 `Option`, `Either`와 같은 기본 자료형을 제공하며 효과를 다루기 위해 기존에 사용한 `Task`, `TaskEither`는 effect를 사용할 것을 권장하고 있다.

해당 라이브러리에 관심이 생겨 관련 문서를 찾아보았지만 자료가 많지 않았고 공식문서조차 매우 부실한 상태이다.  
다행히 프로젝트의 주요 메인테이너인 [mikearnaldi](https://github.com/mikearnaldi)가 발표한 여러 영상이 있어 이를 활용하였다.  
이번 글에서는 발표 영상중 하나인 [Write Efficient & Testable code with effect-ts](https://www.youtube.com/watch?v=Oy7fr2_WBFI)의 내용을 요약하였다.

<!--truncate-->

## 테스트 가능한 코드

테스트 가능한 코드는 보통 다음과 같은 성질이 있다.

- 모듈성
- 단일 목적
- 명시적
- 낮은 결합도
- 순수와 비순수의 분리
- 간결함

함수형 프로그래밍은 보통 테스트 가능한 코드를 작성을 쉽게 만들어주지만 항상 그런것은 아니다.  
잘못 설계된 함수형 코드는 여전히 다른 패러다임으로 만든 코드만큼이나 어려울 수 있다.  
`Effect-ts`는 처음부터 테스트 가능한 코드를 작성하기 위해 설계한 라이브러리이며, 스칼라 언어의 [ZIO](https://zio.dev/)라이브러리를 TypeScript로 포팅한 것이다.

## 순수하지 않은 함수

주어진 이름을 출력하는 간단한 hello world 함수를 생각해보자.

```ts
export function helloWorld(name: string) {
  console.log(`hello world: ${name}!`);
}
```

위와 같은 함수는 함수형 프로그래밍에서 말하는 순수함수가 아니며 다음과 같은 문제가 있다.

- 전역 상태인 `console`을 변경한다.
- 유의미한 값을 반환하지 않는다.
- 구현부를 보지 않고는 함수가 에러를 던질 가능성이 있는지 알 수 없다.
- 내부적으로 `console`을 사용하고 있다는 사실을 내부 구현을 보지 않고는 알 수 없다.

위와 같은 성질로 인해 이 함수는 테스트 하기 어렵다.

## 개선하기

이 함수의 문제점들을 하나씩 개선해보자.

### 유의미한 값을 반환하기

우선 이 함수를 다음과 같이 수정하면 유의미한 반환값을 가지도록 할 수 있다.

```ts
function helloWorld(name: string) {
  return () => {
    console.log(`Hello world: ${name}!`);
  };
}
```

이제 helloWorld 함수는 **콘솔에 문자열을 출력하는 효과를 가진 함수**를 반환한다.  
콘솔에 문자열을 출력하기 위해서는 helloWorld가 반환한 함수를 실행해야 한다.

```ts
const call = helloWorld("Mike");

call(); // Hello world: Mike!
```

함수를 값으로 생각한다면 이 함수는 동일한 name을 주면 항상 동일한 효과를 가진 함수를 반환하므로 순수함수라고 할 수 있다.

### 에러 발생 가능성을 명시적으로 표현하기

helloWorld 함수는 에러를 던질 가능성이 없으며 Either를 사용해 명시적으로 표현할 수 있다.

```ts
// effect-ts의 Either 모듈을 import한다.
import * as E from "@effect-ts/core/Either";

function helloWorld(name: string) {
  return (): E.Either<never, void> => {
    console.log(`Hello world: ${name}!`);
    return E.right(undefined); // 항상 성공하므로 right를 반환한다.
  };
}
```

helloWorld가 반환하는 효과의 타입은 `Either<never, void>`인데 generic type의 첫번째 인자는 에러 타입을 의미하며 두번째 인자는 성공 타입을 의미한다.  
에러의 타입이 never이면 에러를 던지지 않는것을 의미한다.

### console 의존성 제거하기

console과 같은 외부 의존성을 함수 내부에서 직접 사용하기 보다 함수의 인자로 받아서 사용할 수 있다.

```ts
import * as E from "@effect-ts/core/Either";

// IO 효과를 표현하기 위한 타입
type IO<A> = () => A;

// console 의존성에 대한 인터페이스
interface ConsoleService {
  Console: {
    log: (message: string) => IO<E.Either<never, void>>;
  };
}

function helloWorld(name: string) {
  return ({ Console }: ConsoleService) => Console.log(`Hello world: ${name}!`);
}

const program = helloWorld("Mike");

// 의존성 주입
const call = program({
  Console: {
    log: (message: string) => () => {
      console.log(message);
      return E.right(undefined);
    },
  },
});

// 효과 실행
call(); // Hello world: Mike!
```

이제 helloWorld 함수는 외부 의존성을 인자로 받아서 사용하므로 테스트 가능한 코드가 된다.

```ts
it("test hello world", () => {
  // given
  const program = helloWorld("Mike");
  const messages = [];
  const call = program({
    Console: {
      log: (message: string) => () => {
        messages.push(message);
        return E.right(undefined);
      },
    },
  });

  // when
  call();

  // then
  expect(messages).toEqual(["Hello world: Mike!"]);
});
```

하지만 이 함수는 의존성 주입과 효과 실행을 위해 두 번의 연속적인 함수 호출이 필요하다는 단점이 있다.  
또한 함수형 프로그래밍에서 주로 활용하는 함수의 합성을 활용하기 어려운 구조를 가지고 있다.

## Effect-ts 활용하기

이제 본격적으로 Effect-ts를 활용해 helloWorld 함수를 더 개선해보자.

### 의존성과 에러 타입을 하나의 반환값으로 합치기

우선 helloWorld 함수의 의존성과 에러 타입을 하나의 반환값으로 합치는 방법을 알아보자.  
`Effect-ts`에서는 `Effect<R, E, A>`라는 타입을 제공하며 각 generic type의 의미는 다음과 같다.

- `R` : 의존성 타입
- `E` : 에러 타입
- `A` : 성공 타입

이는 fp-ts의 `ReaderTaskEither<R, E, A>`타입과 유사하지만 더 type-safe하며 다양한 combinator를 제공한다.  
이제 기존에 정의한 `ConsoleService` 인터페이스를 수정해보자.

```ts
import * as T from "@effect-ts/core/Effect";

interface ConsoleService {
  log: (message: string) => T.Effect<unknown, never, void>;
}
```

log의 반환타입이 Effect로 변경되었고 의존성 타입이 `unknown`이다.  
이는 효과를 실행하기 위해 어떠한 의존성도 요구하지 않는다는 의미이다.  
console에 의존하는 Effect를 만들기 위해서는 라이브러리에서 제공하는 추가적인 모듈을 사용해야 한다.

```ts
import * as T from "@effect-ts/core/Effect";
import { tag } from "@effect-ts/core/Has";

interface ConsoleService {
  log: (message: string) => T.Effect<unknown, never, void>;
}

// 서비스 태그 만들기
export const ConsoleService = tag<ConsoleService>();

// 서비스 태그를 통해 Effect 생성하는 함수 구현
const log = (message: string) =>
  T.accessServiceM(ConsoleService)((service) => service.log(message));
```

`tag`함수는 프로그램 환경에서 필요한 여러 의존성(서비스)들을 구분하기 위한 태그를 만들어준다.  
`accessServiceM`의 용도가 이해하기 어려울 수 있는데 간단히 말하면 인자로 받는 서비스 태그를 활용해 새로운 Effect를 생성하는 함수이다.

> 앞으로 `tag 생성` -> `accessServiceM 호출` 과정이 반복되기 때문에 Effect를 만들기 위한 boilerplate 코드라고 생각해도 된다.

`log` 함수의 타입을 살펴보면 다음과 같다.

```ts
const log: (message: stirng) => Effect<Has<ConsoleService>, never, void>;
```

함수의 반환타입의 의존성이 `Has<ConsoleService>`로 변경된 것을 확인할 수 있다.  
이는 이 효과가 `ConsoleService`를 필요로 한다는 것을 의미하며 의존성이 아직 주입된 상태가 아니라는 것을 `Has`라는 타입으로 표현한다.

> `Has`라는 타입을 따로 제공하는 이유는 이후 효과를 실행하는 코드를 소개할 때 이해할 수 있다.

### 효과 실행하기
