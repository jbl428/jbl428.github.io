<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Jake Son Blog Blog</title>
        <link>https://jbl428.github.io/</link>
        <description>Jake Son Blog Blog</description>
        <lastBuildDate>Sat, 08 Jan 2022 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[ts-morph 로 개발 컨벤션 검증 자동화하기]]></title>
            <link>https://jbl428.github.io/2022/01/08/convention-check-with-ts-morph</link>
            <guid>/2022/01/08/convention-check-with-ts-morph</guid>
            <pubDate>Sat, 08 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[최근에 typescript 환경에서 개발 컨벤션을 확인하는 작업을 자동화하는 방법을 찾다가 ts-morph 를 도입하게 된 과정을 기술하려고 한다.]]></description>
            <content:encoded><![CDATA[<p>최근에 typescript 환경에서 개발 컨벤션을 확인하는 작업을 자동화하는 방법을 찾다가 <code>ts-morph</code> 를 도입하게 된 과정을 기술하려고 한다.</p><blockquote><p>관련 코드는 아래 링크에서 확인할 수 있다.</p></blockquote><ul><li><a href="https://github.com/jbl428/study-note/tree/master/ts-morph">https://github.com/jbl428/study-note/tree/master/ts-morph</a></li></ul><h2>컨벤션</h2><p>아래와 같은 <code>TypeORM</code> 엔티티 파일이 있다고 가정한다.</p><pre><code class="language-ts" metastring="title=&quot;Profile.entity.ts&quot;" title="&quot;Profile.entity.ts&quot;">import { Column, Entity, PrimaryGeneratedColumn } from &quot;typeorm&quot;;

@Entity()
export class Profile {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @Column()
  email: string;
}
</code></pre><pre><code class="language-ts" metastring="title=&quot;Post.entity.ts&quot;" title="&quot;Post.entity.ts&quot;">import {
  Column,
  Entity,
  Index,
  JoinColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
} from &quot;typeorm&quot;;
import { Profile } from &quot;./Profile.entity&quot;;

@Entity()
// highlight-start
@Index(&quot;idx_post_1&quot;, [&quot;profile&quot;]) // profile_id 에 인덱스를 추가
@Index(&quot;idx_post_2&quot;, [&quot;status&quot;]) // status 필드에 인덱스를 추가
// highlight-end
export class Post {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  content: string;

  @Column()
  status: string;

  // highlight-start
  // profile 과 1:n 관계이지만 FK 를 설정하지 않음
  @ManyToOne(() =&gt; Profile, { createForeignKeyConstraints: false })
  // profile 연관관계 필드 추가
  @JoinColumn({ name: &quot;profile_id&quot;, referencedColumnName: &quot;id&quot; })
  profile: Profile;
  // highlight-end
}
</code></pre><p><code>Post</code> 엔티티는 <code>Profile</code> 과 1:N 관계이고 <code>profile_id</code> 필드가 있지만 외래키를 추가하지 않고 대신 class 상단에 <code>@Index</code> 데코레이터를 이용해 인덱스를 추가한다.
인덱스를 추가하지 않으면 join 성능이 떨어지기 때문에 개발자가 인덱스를 추가하지 않는 실수를 하지 않도록 검증과정을 자동화하려고 했다.</p><h2>Shell script 로 검증</h2><p>처음에는 bash 스크립트를 활용해서 각 엔티티 파일을 읽은 후 정규식을 활용해 검증을 시도하려 했지만 다음과 같은 이유로 하지 않았다.</p><h3>OS</h3><p>현재 개발팀 모두 mac 을 사용하기에 스크립트를 실행하는데 어려움이 없지만 추후에 윈도우를 사용하는 사람이 올 수도 있다.
스크립트를 CI 에서 실행하면 큰 문제는 없지만 OS 에 관계없이 누구나 로컬에서 편리하게 검증할 수 있도록 하고 싶었다.</p><h3>유지보수</h3><p>shell script 에 익숙하지 않은 개발자도 있어서 해당 스크립트를 유지보수 할 수 있는 사람이 적어진다.
개발환경과 같은 언어를 활용해 검증을 한다면 코드를 이해하고 개선할 수 있는 사람이 많아질것이다.</p><h3>구현</h3><p>검증을 위해서 파일 내용 중 <code>JoinColumn</code> 데코레이터로 선언한 필드명 (예제에서는 <code>profile</code>) 을 알아내야 하는데 코드 상황에 따라 그 위치가 달라질 수 있다.</p><ul><li>JoinColumn 라인 바로 아래에 컬럼명이 존재</li></ul><pre><code class="language-ts">@ManyToOne(() =&gt; Profile, { createForeignKeyConstraints: false })
@JoinColumn({ name: &quot;profile_id&quot;, referencedColumnName: &quot;id&quot; })
profile: Profile;
</code></pre><ul><li>JoinColumn 두 라인 아래에 컬럼명이 존재</li></ul><pre><code class="language-ts">@JoinColumn({ name: &quot;profile_id&quot;, referencedColumnName: &quot;id&quot; })
@ManyToOne(() =&gt; Profile, { createForeignKeyConstraints: false })
profile: Profile;
</code></pre><ul><li>JoinColumn 세 라인 아래에 컬럼명이 존재</li></ul><pre><code class="language-ts">@ManyToOne(() =&gt; Profile, { createForeignKeyConstraints: false })
@JoinColumn({
  name: &quot;profile_id&quot;,
  referencedColumnName: &quot;id&quot;
})
profile: Profile;
</code></pre><ul><li>JoinColumn 과 같은 라인에 존재</li></ul><pre><code class="language-ts">@ManyToOne(() =&gt; Profile, { createForeignKeyConstraints: false })
@JoinColumn({ name: &quot;profile_id&quot;, referencedColumnName: &quot;id&quot; }) profile: Profile;
</code></pre><p><code>prettier</code> 를 사용하면 몇가지 상황은 배제할 수 있지만 컬럼명을 알아내기 위해 multiline 에 대한 정규식 표현을 사용해야 하는 불편함이 있다.
그리고 컬럼명을 가져온 후 <code>@Index</code> 에 선언된 컬렴명과 비교하는 로직을 shell script 로 구현하기도 복잡하다.</p><p>위와 같은 이유로 shell script 보다 개발환경과 같은 언어인 typescript 을 활용하고 싶었고 이전부터 눈여겨본 <code>ts-morph</code> 를 도입해보았다.</p><h2>ts-morph</h2><p><a href="https://github.com/dsherret/ts-morph/tree/latest/packages/ts-morph">ts-morph</a> 는 난해한 <code>typescript ast</code> 를 사용하기 편리하게 만든 wrapper 라이브러리이다.
타입스크립트 코드를 프로그래밍 적으로 분석 및 수정할 수 있게한다.
사용법 자체도 간단해서 이번에 문서를 보고 처음 사용해보았는데 어렵지 않게 작업할 수 있었다.
각 ast 노드를 클래스 인스턴스로 만들어 각 클래스의 메소드를 활용해 자식 노드나 부가정보를 얻을 수 있는 형태로 구현되어있다.</p><h3>Project 생성</h3><p>먼저 Project 인스턴스를 생성해야 한다. 생성자에 파싱을 위한 소스파일 정보를 주거나 이후에 메소드를 통해 제공할 수 있다.
tsconfig.json 경로를 제공하면 해당 파일에 적용되는 ts 파일들을 자동으로 읽는다.</p><pre><code class="language-ts">import { Project } from &quot;ts-morph&quot;;

const project = new Project({
  tsConfigFilePath: &quot;path/to/tsconfig.json&quot;,
});
</code></pre><p>아니면 인스턴스 생성이후 메소드를 호출해 소스파일을 등록할 수 있다.</p><pre><code class="language-ts">const project = new Project();

project.addSourceFilesFromTsConfig(&quot;dir1/tsconfig.json&quot;); // tsconfig.json 파일 경로지정
project.addSourceFilesAtPaths(&quot;dir3/**/*{.d.ts,.ts}&quot;); // 경로에 해당하는 파일읽기
</code></pre><p>실제 파일내용을 제공할 수도 있어서 테스트코드 작성할 때 유용하게 쓸 수 있다.</p><pre><code class="language-ts">const project = new Project();

const fileText = &quot;enum MyEnum {\n}\n&quot;;
const sourceFile = project.createSourceFile(&quot;path/to/myNewFile.ts&quot;, fileText);
</code></pre><p>소스파일 경로를 지정하는 방법과 파일내용을 제공하는 방법을 모두 지원하기 위해 아래와 같은 클래스를 만들었다.</p><pre><code class="language-ts" metastring="title=&quot;EntityValidator.ts&quot;" title="&quot;EntityValidator.ts&quot;">export class EntityValidator {
  #project: Project;

  constructor(path: string, content?: string) {
    this.#project = new Project();

    if (content) {
      this.#project.createSourceFile(path, content);
      return;
    }

    this.#project.addSourceFilesAtPaths(path);
  }
}
</code></pre><h3>SourceFile 가져오기</h3><p>이제 ast 의 root 인 SourceFile 을 가져온다.</p><pre><code class="language-ts">const sourceFiles = this.#project.getSourceFiles();
</code></pre><h3>Entity Class 가져오기</h3><p>이제 각 SourceFile 배열을 순회하면서 각 파일이 컨벤션을 만족하는지 확인하는 과정이 필요하다.
우선 하나의 SourceFile 을 검증하는 로직을 먼저 구현해보자.
먼저 해당 파일이 Entity 데코레이터가 있는 클래스가 선언되어 있는지 확인해본다.</p><p>SourceFile 에는 <code>getClass</code> 메소드가 있는데 파라미터로 필터함수를 주면 조건에 해당하는 첫 번째 클래스를 반환한다.
해당 함수는 클래스의 데코레이터 중 이름이 <code>Entity</code> 가 있을 때 true 를 반환하도록 하였다.</p><pre><code class="language-ts">private getClass(sourceFile: SourceFile): ClassDeclaration {
  // highlight-start
  // Entity 데코레이터가 있는 클래스를 가져오기
  const entityClass = sourceFile.getClass((declaration) =&gt;
    declaration
      .getDecorators()
      .some((decorator) =&gt; decorator.getFullName() === &#x27;Entity&#x27;),
  );
  // highlight-end

  if (!entityClass) {
    throw new Error(&#x27;Entity 데코레이터가 존재하지 않습니다&#x27;);
  }

  return entityClass;
}
</code></pre><h3>JoinColumn 데코레이터가 선언된 필드명을 가져오기</h3><p>이제 해당 클래스에서 <code>JoinColumn</code> 데코레이터가 선언된 필드명을 가져온다.
코드를 보면 <code>getProperties</code> 메소드를 통해 필드를 가져온 후 데코레이터 이름이 <code>JoinColumn</code> 인것만 필터링 후 <code>getName</code> 을 통해 필드명을 가져온다.
메소드명만 읽어도 어떤 작업을 하는지 파악이 가능하기에 유지보수가 쉽고 코드를 읽기 쉽다는 장점이있다.</p><pre><code class="language-ts">private getJoinColumns(entityClass: ClassDeclaration): string[] {
  return entityClass
    .getProperties()
    .filter((property) =&gt;
      property
        .getDecorators()
        .some((decorator) =&gt; decorator.getFullName() === &#x27;JoinColumn&#x27;),
    )
    .map((property) =&gt; property.getName());
}
</code></pre><h3>JoinColumn 에 매칭되는 Index 데코레이터가 있는 필드 가져오기</h3><p><code>JoinColumn</code> 에 해당하는 필드명 중에 클래스에 선언된 Index 데코레이터의 두 번째 파라미터와 일치하는게 존재하는 것만 필터링한다.
단순히 모든 Index 데코레이터 정보를 사용하지 않고 필터링 해야하는 이유는 JoinColumn 이 없는 필드에 대해서도 Index 데코레이터를 사용하는 경우가 있기 때문이다.</p><pre><code class="language-ts">private getIndexColumns(
  entityClass: ClassDeclaration,
  joinColumns: string[],
): string[] {
  return entityClass
    .getDecorators()
    .filter((decorator) =&gt; decorator.getFullName() === &#x27;Index&#x27;)
    // getArguments 는 데코레이터의 파리마터를 반환한다
    .map((decorator) =&gt; decorator.getArguments())
    // Node.getFullText 메소드는 실제 파라미터 타입이 아닌 코드에 있는 문자열 그대로 반환한다.
    // 따라서 [&#x27;column&#x27;] 과 같이 배열로 선언되어 있어도 문자열이 되며
    // parseArgument 메소드는 특수문자를 모두 제거해서 컬럼명만 남긴다.
    .map(([_, indexField]) =&gt; this.parseArgument(indexField))
    .filter((columnName) =&gt; joinColumns.includes(columnName));
}

private parseArgument(node?: Node): string {
  if (!node) {
    return &#x27;&#x27;;
  }

  // 특수문자를 모두 제거
  return node.getFullText().replace(/[\W\s]/gi, &#x27;&#x27;);
}
</code></pre><h3>검증하기</h3><p>위 메소드를 활용해서 각 SourceFile 를 순회해 <code>JoinColumn</code> 의 개수와 <code>Index</code> 개수가 일치하지 않으면 에러를 발생시킨다.</p><pre><code class="language-ts">validate(): void {
  const sourceFiles = this.#project.getSourceFiles();

  sourceFiles.forEach((sourceFile) =&gt; {
    const entityClass = this.getClass(sourceFile);
    const joinColumns = this.getJoinColumns(entityClass);
    const indexColumns = this.getIndexColumns(entityClass, joinColumns);

    if (indexColumns.length !== joinColumns.length) {
      throw new Error(
        `JoinColumn 에 매칭되는 Index 선언이 누락되었습니다: ${JSON.stringify(
          {
            entity: entityClass.getName(),
            joinColumns,
            indexColumns,
          },
          null,
          2,
        )}`,
      );
    }
  });
}
</code></pre><h2>테스트</h2><p>이제 위 클래스가 정상 동작하는지 테스트를 작성해본다.
<code>EntityValidator</code> 생성자의 두 번째 파라미터에 파일내용을 직접 넣어서 테스트 할 수 있다.</p><pre><code class="language-ts" metastring="title=&quot;EntityValidator.spec.ts&quot;" title="&quot;EntityValidator.spec.ts&quot;">import { EntityValidator } from &quot;./EntityValidator&quot;;

describe(&quot;EntityValidator&quot;, () =&gt; {
  it(&quot;JoinColumn 에 선언된 컬럼에 인덱스가 없으면 에러가 발생한다&quot;, () =&gt; {
    // given
    const path = &quot;post.ts&quot;;
    const content = `
@Entity()
export class Post {
  @ManyToOne(() =&gt; Profile, { createForeignKeyConstraints: false })
  @JoinColumn({ name: &#x27;profile_id&#x27;, referencedColumnName: &#x27;id&#x27; })
  profile: Profile;
}`;
    const checker = new EntityValidator(path, content);

    // when
    const validate = () =&gt; checker.validate();

    // then
    expect(validate).toThrowError();
  });

  it(&quot;JoinColumn 에 선언된 컬럼에 인덱스가 있으면 검증에 성공한다&quot;, () =&gt; {
    // given
    const content = `
@Entity()
@Index(&#x27;idx_post_1&#x27;, [&#x27;profile&#x27;])
export class Post {
  @ManyToOne(() =&gt; Profile, { createForeignKeyConstraints: false })
  @JoinColumn({ name: &#x27;profile_id&#x27;, referencedColumnName: &#x27;id&#x27; })
  profile: Profile;
}`;
    const checker = new EntityValidator(content);

    // when
    const validate = () =&gt; checker.validate();

    // then
    expect(validate).not.toThrowError();
  });

  it(&quot;JoinColumn 이 아닌 컬럼에 대한 인덱스가 있어도 검증에 성공한다&quot;, () =&gt; {
    // given
    const content = `
@Entity()
@Index(&#x27;idx_post_1&#x27;, [&#x27;profile&#x27;])
@Index(&#x27;idx_post_2&#x27;, [&#x27;name&#x27;])
export class Post {
  @Column()
  name: string

  @ManyToOne(() =&gt; Profile, { createForeignKeyConstraints: false })
  @JoinColumn({ name: &#x27;profile_id&#x27;, referencedColumnName: &#x27;id&#x27; })
  profile: Profile;
}`;
    const checker = new EntityValidator(content);

    // when
    const validate = () =&gt; checker.validate();

    // then
    expect(validate).not.toThrowError();
  });
});
</code></pre><p>마지막으로 실제 엔티티 파일이 있는 경로를 지정해서 컨벤션을 만족하는지 검증한다.
테스트코드를 통해 검증하기 때문에 로컬과 CI 에서 손쉽게 사용할 수 있다는 장점이있다.</p><pre><code class="language-ts">it(&quot;엔티티 파일들은 JoinColumn 에 대한 인덱스가 존재한다&quot;, () =&gt; {
  // given
  const path = join(__dirname, &quot;../src/**/*.entity.ts&quot;);
  const checker = new EntityValidator(path);

  // when
  const validate = () =&gt; checker.validate();

  // then
  expect(validate).not.toThrowError();
});
</code></pre><h2>마무리</h2><p><code>ts-morph</code> 를 활용해 컨벤션 검증과정을 살펴보았다.
해당 라이브러리는 소스코드를 수정하는 기능도 있기 때문에 컨벤션에 맞지 않으면 자동으로 해결하는 기능도 추가할 수 있다.
또한 클래스 외에 함수, 인터페이스, Enum 등 다른 유형의 코드도 파싱할 수 있기 때문에 다양한 컨벤션을 검증하는 로직을 만들 수 있다.</p><h2>참고문서</h2><ul><li>ts-morph documentation: <a href="https://ts-morph.com/">https://ts-morph.com/</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[코틀린 환경에서 Querydsl 설정하기]]></title>
            <link>https://jbl428.github.io/2022/01/05/querydsl-in-kotlin</link>
            <guid>/2022/01/05/querydsl-in-kotlin</guid>
            <pubDate>Wed, 05 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[최근에 코틀린과 스프링을 활용해 사이드 프로젝트를 하면서 querydsl 사용을 위해 세팅한 작업을 남기려고 한다.]]></description>
            <content:encoded><![CDATA[<p>최근에 코틀린과 스프링을 활용해 사이드 프로젝트를 하면서 querydsl 사용을 위해 세팅한 작업을 남기려고 한다.
자바로 된 querydsl 관련 블로그 글은 많은데 생각보다 코틀린은 적었고 제대로 적용이 안되어 고생을 하게되었다.</p><h2>최종 설정</h2><p>결론부터 먼저 말하면 querydsl 버전을 현재 시점 최신버전인 <code>5.0.0</code> 을 사용하면 정상적으로 동작한다.
그리고 <code>kotlinOption 의 jvmTarget</code> 버전과 <code>java.sourceCompatibility</code> 에 지정한 버전이 일치해야한다.
gradle 설정은 아래와 같다.</p><pre><code class="language-kotlin" metastring="title=&quot;build.gradle.kts&quot;" title="&quot;build.gradle.kts&quot;">import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
    id(&quot;org.springframework.boot&quot;) version &quot;2.6.2&quot;
    id(&quot;io.spring.dependency-management&quot;) version &quot;1.0.11.RELEASE&quot;

    kotlin(&quot;jvm&quot;) version &quot;1.6.10&quot;
    kotlin(&quot;plugin.spring&quot;) version &quot;1.6.10&quot;
    kotlin(&quot;plugin.jpa&quot;) version &quot;1.6.10&quot;
    // highlight-next-line
    kotlin(&quot;kapt&quot;) version &quot;1.6.10&quot; // kapt 추가
}

repositories {
    mavenCentral()
}

// highlight-next-line
java.sourceCompatibility = JavaVersion.VERSION_11 // jvmTarget 과 같은 버전으로 지정

dependencies {
    // highlight-start
    // querydsl 관련 패키지 추가. 버전은 5.0.0 으로 지정
    implementation(&quot;org.springframework.boot:spring-boot-starter-data-jpa&quot;)
    implementation(&quot;com.querydsl:querydsl-jpa:5.0.0&quot;)
    kapt(&quot;com.querydsl:querydsl-apt:5.0.0:jpa&quot;)
    // highlight-end
}

tasks.withType&lt;KotlinCompile&gt; {
    kotlinOptions {
        freeCompilerArgs = listOf(&quot;-Xjsr305=strict&quot;)
        // highlight-next-line
        jvmTarget = &quot;11&quot; // java.sourceCompatibility 과 같은 버전 지정
    }
}

tasks.withType&lt;Test&gt; {
    useJUnitPlatform()
}
</code></pre><h2>문제 상황</h2><p>querydsl 공식문서에는 gradle 설정은 없고 maven 만 존재해서 여러 블로그 글을 참조해서 설정하려고 했다.
문서에도 모두 4.x.x 버전을 쓰고있고 공식 홈페이지에도 4.4.0 이 최신버전인지라 그대로 사용했지만 Qclass 생성 시 아래 메시지가 출력되고 아무런 파일이 생성되지 않았다.</p><pre><code class="language-shell">gradle clean compileKotlin
&gt; Task :kaptKotlin
[WARN] Can&#x27;t find annotation processor class com.querydsl.apt.jpa.JPAAnnotationProcessor: com/mysema/codegen/model/Type
</code></pre><p><code>annotation processor</code> 관련 문제로 보여 관련 문서를 검색해고 제시된 해결방법을 시도해보았지만 여전히 같은 에러를 출력했다.
kotlin 을 최신버전을 사용하고 있어서 새로운 호환성 문제가 생긴건지 의심이 들었고 querydsl 도 최신버전으로 올려서 시도해보았다.
이후 해당 메시지는 사라졌지만 새로운 메시지가 출력됐다.</p><pre><code class="language-shell">gradle clean compileKotlin
&gt; Task :kaptKotlin
&#x27;compileJava&#x27; task (current target is 17) and &#x27;compileKotlin&#x27; task (current target is 11) jvm target compatibility should be set to the same Java version.
</code></pre><p>이번 에러는 메시지만 봐도 쉽게 해결할 수 있는 내용이었고 <code>jvmTarget</code> 과 <code>java.sourceCompatibility</code> 를 동일하게 맞추니 정상적으로 동작했다.
querydsl 5.0.0 릴리즈 노트를 보면 아래 내용이 있는데 자바 11 지원과 코틀린 코드 생성과 관련된 작업을 한것이 해결이 된 원인으로 보인다.</p><p><img src="./querydsl.png" alt="querydsl"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[TypeORM CreateDateColumn 데코레이터와 value transformer 문제]]></title>
            <link>https://jbl428.github.io/2021/12/09/typeorm-transformer</link>
            <guid>/2021/12/09/typeorm-transformer</guid>
            <pubDate>Thu, 09 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[문제 상황]]></description>
            <content:encoded><![CDATA[<h3>문제 상황</h3><p>보통 테이블에 기본으로 넣는 생성시간과, 수정시간 필드를 추가하기 위해 typeorm 사용하는 환경에서는 데코레이터와 상속을 사용한다.
예를들어 아래와 같은 클래스를 만든 후 다른 엔티티 클래스가 상속받는 방법으로 구현하게 된다.</p><pre><code class="language-ts">import { CreateDateColumn, UpdateDateColumn } from &quot;typeorm&quot;;

export abstract class BaseEntity {
  @CreateDateColumn({ type: &quot;timestamp&quot; })
  createdAt: Date;

  @UpdateDateColumn({ type: &quot;timestamp&quot; })
  updatedAt: Date;
}
</code></pre><p>하지만 각 필드의 타입을 Date 대신 서드파티 라이브러리의 날짜 타입으로 바꾸기 위해서는 <code>value transformer</code> 를 사용해야 하지만 에러가 발생한다.</p><pre><code class="language-ts">import { CreateDateColumn, UpdateDateColumn } from &quot;typeorm&quot;;
import { LocatDateTime } from &quot;@js-joda/core&quot;;

export abstract class BaseEntity {
  @CreateDateColumn({
    type: &quot;timestamp&quot;,
    transformer: new LocalDateTransformer(),
  })
  createdAt: LocalDateTime;

  @UpdateDateColumn({
    type: &quot;timestamp&quot;,
    transformer: new LocalDateTransformer(),
  })
  updatedAt: LocalDateTime;
}
</code></pre><p>:::info
여기서 LocalDateTransformer 는 typeorm 의 ValueTransformer 인터페이스를 구현한 클래스로
js 의 Date 와 LocalDateTime 간의 변환로직이 있다.
:::</p><p>typeorm 공식 저장소에 이와같은 이슈가 올라와 있지만 (2020년 12월) 아직도 해결되지 않고있다.</p><ul><li><a href="https://github.com/typeorm/typeorm/issues/7150">UpdateDateColumn fails with transformer</a></li></ul><h3>해결 방안</h3><p>이를 해결하기 위해 <code>@CreateDateColumn</code> 데코레이터 대신 <code>@Column</code>, <code>@BeforeInsert</code>, <code>@BeforeUpdate</code> 를 활용한다.</p><pre><code class="language-ts">import { BeforeInsert, BeforeUpdate, Column } from &quot;typeorm&quot;;
import { LocalDateTime } from &quot;@js-joda/core&quot;;

export abstract class BaseEntity {
  @Column({
    type: &quot;timestamptz&quot;,
    transformer: new LocalDateTimeTransformer(),
    nullable: false,
    update: false,
  })
  createdAt: LocalDateTime;

  @Column({
    type: &quot;timestamptz&quot;,
    transformer: new LocalDateTimeTransformer(),
    nullable: false,
  })
  updatedAt: LocalDateTime;

  @BeforeInsert()
  protected beforeInsert() {
    this.createdAt = LocalDateTime.now();
    this.updatedAt = LocalDateTime.now();
  }

  @BeforeUpdate()
  protected beforeUpdate() {
    this.updatedAt = LocalDateTime.now();
  }
}
</code></pre><p><code>@BeforeInsert</code> 와 <code>@BeforeUpdate</code> 는 이름 그대로 테이블에 새로운 row 가 추가되기 전이나 기존 row 수정작업 전에 실행된다.
정상 동작하는지 테스트코드를 작성해보자.</p><pre><code class="language-ts">import {
  Connection,
  createConnection,
  Entity,
  PrimaryGeneratedColumn,
  Repository,
} from &quot;typeorm&quot;;
import { LocalDateTime } from &quot;@js-joda/core&quot;;

@Entity()
class TestEntity extends BaseEntity {
  @PrimaryGeneratedColumn(&quot;increment&quot;)
  id: number;
}

describe(&quot;TestEntityRepository&quot;, () =&gt; {
  let testEntityRepository: Repository&lt;TestEntity&gt;;
  let connection: Connection;

  beforeAll(async () =&gt; {
    connection = await createConnection({
      type: &quot;postgres&quot;,
      host: &quot;localhost&quot;,
      port: 5432,
      username: &quot;test&quot;,
      password: &quot;test&quot;,
      database: &quot;test&quot;,
      entities: [TestEntity],
      synchronize: true,
    });

    testEntityRepository = connection.getRepository(TestEntity);
  });

  afterAll(() =&gt; connection.close());

  beforeEach(() =&gt; testEntityRepository.clear());

  it(&quot;save 메소드로 insert 시 createdAt, updatedAt 이 현재시간으로 들어간다&quot;, async () =&gt; {
    // given
    const nowTime = LocalDateTime.now();
    const entity = new TestEntity();

    // when
    const testEntity = await testEntityRepository.save(entity);

    // then
    expect(testEntity.createdAt.isAfter(nowTime)).toBeTruthy();
    expect(testEntity.updatedAt.isAfter(nowTime)).toBeTruthy();
  });

  it(&quot;insert 메소드로 insert 시 createdAt, updatedAt 이 현재시간으로 들어간다&quot;, async () =&gt; {
    // given
    const nowTime = LocalDateTime.now();
    const entity = new TestEntity();

    // when
    await testEntityRepository.insert(entity);

    // then
    const testEntity = await testEntityRepository.findOneOrFail();
    expect(testEntity.createdAt.isAfter(nowTime)).toBeTruthy();
    expect(testEntity.updatedAt.isAfter(nowTime)).toBeTruthy();
  });

  it(&quot;save 메소드로 엔티티 업데이트 시 updatedAt 이 갱신된다&quot;, async () =&gt; {
    // given
    const testEntity = await testEntityRepository.save(new TestEntity());
    const before = testEntity.updatedAt;

    // when
    const updatedTestEntity = await testEntityRepository.save(testEntity);

    // then
    expect(updatedTestEntity.updatedAt.isAfter(before)).toBeTruthy();
  });

  it(&quot;update 메소드로 엔티티 업데이트 시 updatedAt 이 갱신된다&quot;, async () =&gt; {
    const testEntity = await testEntityRepository.save(new TestEntity());
    const before = testEntity.updatedAt;

    // when
    await testEntityRepository.update(testEntity.id, testEntity);

    // then
    const updatedTestEntity = await testEntityRepository.findOneOrFail();
    expect(updatedTestEntity.updatedAt.isAfter(before)).toBeTruthy();
  });
});
</code></pre><p>대부분의 상황에서 정상적으로 동작하지만 <code>queryBuilder</code> 를 사용해 update 를 수행할 때에는 updatedAt 이 갱신되지 않는다.</p><pre><code class="language-ts">it(&quot;queryBuilder 로 업데이트 시 updatedAt 갱신되지 않는다&quot;, async () =&gt; {
  // given
  const testEntity = await testEntityRepository.save(new TestEntity());
  const before = testEntity.updatedAt;

  // when
  await testEntityRepository
    .createQueryBuilder(&quot;testEntity&quot;)
    .update()
    .set({ id: 3 })
    .execute();

  // then
  const updatedTestEntity = await testEntityRepository.findOneOrFail();
  expect(updatedTestEntity.updatedAt.isEqual(before)).toBeTruthy();
});
</code></pre><p>위 경우에는 명시적으로 현재시간을 넣어주어야 한다.</p><pre><code class="language-ts">it(&quot;queryBuilder 로 업데이트 시 updatedAt 갱신된다&quot;, async () =&gt; {
  // given
  const testEntity = await testEntityRepository.save(new TestEntity());
  const before = testEntity.updatedAt;

  // when
  await testEntityRepository
    .createQueryBuilder(&quot;testEntity&quot;)
    .update()
    .set({ id: 100, updatedAt: LocalDateTime.now() })
    .execute();

  // then
  const updatedTestEntity = await testEntityRepository.findOneOrFail();
  expect(updatedTestEntity.updatedAt.isAfter(before)).toBeTruthy();
});
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Promise 와 Monad - 2]]></title>
            <link>https://jbl428.github.io/2021/11/28/promise-and-monad-2</link>
            <guid>/2021/11/28/promise-and-monad-2</guid>
            <pubDate>Sun, 28 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[이전 글에서는 promise 를 반환하는 함수들을 then 을 이용해 합성하는 과정을 살펴보았다.]]></description>
            <content:encoded><![CDATA[<p>이전 글에서는 promise 를 반환하는 함수들을 then 을 이용해 합성하는 과정을 살펴보았다.
이제 파라미터를 2개 이상 요구하는 함수가 있는 경우를 살펴보자.</p><h2>add 함수와 비동기 함수</h2><p>간단하게 add 함수를 정의하고 각 파라미터는 비동기 함수의 반환값을 통해 가져온다고 생각해보자.</p><pre><code class="language-ts">declare function getFirstNumber(): Promise&lt;number&gt;;
declare function getSecondNumber(first: number): Promise&lt;number&gt;;
declare function add(a: number, b: number): number;
</code></pre><p>이전 글에서 소개한 방법대로 then 을 이용해보면 문제가 발생한다.</p><pre><code class="language-ts">getFirstNumber()
  .then((a) =&gt; getSecondNumber(a))
  .then((b) =&gt; add(a, b)); // a 를 참조할 수 없다
</code></pre><p><code>getFirstNumber</code> 가 반환한 값은 오직 첫번째 then 내부 함수에서만 접근 가능하고 두번째에서는 b 만 참조할 수 있다.
물론 <code>Promise.all</code> 이나 상단에 임시변수를 선언하는 방식으로 해결할 수 있지만 깔끔한 방법은 아니다.</p><pre><code class="language-ts">// temporary variable
let temp: number;
getFirstNumber()
  .then((a) =&gt; {
    temp = a;
    return getSecondNumber(a);
  })
  .then((b) =&gt; add(temp, b));

// Promise.all
getFirstNumber()
  .then((a) =&gt; Promise.all([getSecondNumber(a), a]))
  .then(([a, b]) =&gt; add(a, b));
</code></pre><p>내부 함수가 외부 함수의 변수를 참조할 수 있는 성질을 활용해서 아래와 같이 활용할 수도 있다.</p><pre><code class="language-ts" metastring="{3}">getFirstNumber().then((a) =&gt; {
  return getSecondNumber(a).then((b) =&gt; {
    return add(a, b);
  });
});
</code></pre><p>가장 안쪽에 있는 <code>(b) =&gt; { return add(a, b) }</code> 함수는 바깥쪽 함수의 파라미터인 a를 참조할 수 있기 때문에 위 코드는 정상적으로 동작한다.
하지만 이 방법도 특정 함수가 필요한 파라미터 개수가 많아질수록 callback hell 처럼 들여쓰기가 많아질 수 있는 문제가 있다.</p><pre><code class="language-ts">A().then((a) =&gt; {
  return B().then((b) =&gt; {
    return C().then((c) =&gt; {
      return D().then((d) =&gt; {
        return a + b + c + d;
      });
    });
  });
});
</code></pre><h2>async / await 와 do notation</h2><p>위와 같은 문제를 해결하기 위해 <code>async/await</code> 가 도입되었고 아래와 같이 작성할 수 있다.</p><pre><code class="language-ts">async function addNumber() {
  const a = await getFirstNumber();
  const b = await getSecondNumber(a);

  return add(a, b);
}
</code></pre><p>마치 2개의 함수의 반환값을 지역변수 a 와 b 에 할당한 후 add 를 호출하는 코드처럼 작성할 수 있다.
순수 함수형 언어인 하스켈도 이와 비슷한 <code>do notation</code> 이 존재한다.</p><pre><code class="language-hs">addNumber :: IO Int
addNumber = do
    a &lt;- getFirstNumber
    b &lt;- getSecondNumber a
    return add a b
</code></pre><p>하스켈의 <code>do natation</code> 이 monad 를 반환하는 함수들을 활용한 로직을 절차적으로 표시하는 역할을 해준다.
마찬가지로 <code>async/await</code> 도 promise 를 반환하는 함수들을 활용한 로직을 절차적으로 표시하는 역할을 해준다.</p><h2>promise 와 monad</h2><p>이쯤에서 monad 에 대한 설명을 하자면 어떤 타입에 특별한 문맥을 더해주는 컨테이너라 말할 수 있다.
예를들면 <code>number</code> 는 일반적인 숫자타입이지만 거기에 promise 로 감싸면 안의 숫자는 일정시간이 지난 후 값을 알게된다는 문맥을 더해준다.</p><pre><code class="language-ts">const a: number = 3; // a 는 평가시점에 그 값과 타입을 바로 알 수 있다.
const b: Promise&lt;number&gt; = new Promise((resolve) =&gt;
  setTimeout(() =&gt; resolve(5), 1000)
); // 컨테이너 안의 값은 평가시점이후 일정 시간이 지난 후에 알 수 있는데 그 타입은 number 이다.
</code></pre><p>사실 컨테이너의 종류는 promise 외에 여러가지가 있으며 직접 컨테이너를 만들수도 있다.</p><h2>Monad laws</h2><p>만약 컨테이너를 직접 만드는 경우 만든 컨테이너는 어떤 법칙을 만족해야 monad 라고 부를 수 있게된다.
monad 는 category theory 에서 나온 개념이기에 다분히 수학적인 법칙이며 다음 3가지이다.</p><ul><li>Left identity</li><li>Right identity</li><li>Associativity</li></ul><p>예전에 배운 덧셈의 항등법칙과 결합법칙과 비슷한 개념으로 생각하면 된다.
이 글의 목적은 monad 에 대한 완벽한 이해보다 그 유용성을 알리기 위함이기에 자세한 설명은 생략하려고 한다.</p><p>:::info
사실 promise 는 특정 조건에서는 위 법칙을 만족하기 않기에 monad 라고 할 수 없다.
하지만 js 개발자에게 monad 의 유용성을 설명하는데 promise 만한게 없다고 생각하기에 약간의 정확성을 포기하였다.
만약 어떤 이유로 법칙을 만족하지 않는지 알고싶다면 참고자료의 링크를 참조한다.
:::</p><h2>참고자료</h2><p>No, Promise is not a monad: <a href="https://buzzdecafe.github.io/2018/04/10/no-promises-are-not-monads">https://buzzdecafe.github.io/2018/04/10/no-promises-are-not-monads</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Promise 와 Monad - 1]]></title>
            <link>https://jbl428.github.io/2021/11/07/promise-and-monad-1</link>
            <guid>/2021/11/07/promise-and-monad-1</guid>
            <pubDate>Sun, 07 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[예전 node.js 의 많은 비동기 함수는 결과를 함수로 받는 콜백형태로 이루어져 있었다.]]></description>
            <content:encoded><![CDATA[<p>예전 <code>node.js</code> 의 많은 비동기 함수는 결과를 함수로 받는 콜백형태로 이루어져 있었다.
이로인해 여러 비동기 로직을 순차적으로 실행하는 코드를 보면 일명 <code>Callback Hell</code> 이라는 것을 볼 수 있다.</p><pre><code class="language-js">asyncA((a) =&gt; {
  asyncB((b) =&gt; {
    asyncC((c) =&gt; {
      asyncD((d) =&gt; {
        return a + b + c + d;
      });
    });
  });
});
</code></pre><p>이후 이를 해결하는 방안으로 여러 라이브러리나 기술들이 나왔으나 지금은 주로 <code>promise</code> 와 <code>async/await</code> 를 활용한다.</p><p>사실 나는 <code>angular</code> 를 통해 js 를 본격적으로 사용했기에 비동기 처리를 <code>rxjs</code> 의 <code>observable</code> 을 사용해왔다.
하지만 백엔드 개발자가 된 이후로 api 를 개발하는데 사용하는 대부분의 함수가 <code>promise</code> 를 반환하다보니 <code>observable</code> 을 활용하지 않게되었다.</p><p><code>promise</code> 를 본격적으로 사용했을 때에는 이미 <code>async/await</code> 가 도입된 이후였고 동기적으로 보이는 코드를 작성하는데 큰 어려움 없었다.
그래서 굳이 <code>then</code> 이나 <code>catch</code> 구문을 사용할 필요가 없다고 생각했었다.
그러나 함수형 패러다임을 공부하면서 함수의 합성, 선언적인 코드, pointfree 에 대한 매력을 느꼈고 이를 <code>then chaining</code> 을 통해 이룰 수 있다는 것을 깨달았다.
함수형 패러다임 중 난해한 <code>monad</code> 도 <code>promise</code> 와 비교하면서 생각하니 이해하는데 많은 도움을 받았다.
그래서 이와 관련한 글을 작성하려고 한다.</p><h2>함수로 나누기</h2><p>다음과 같은 작업을 하는 코드를 작성한다고 가정해본다.</p><ul><li>user 테이블에서 주어진 id 에 해당하는 row 를 가져온다.</li><li>가져온 사용자에서 이름 필드만 추출한다.</li><li>추출한 이름을 대문자로 변경한다.</li><li>post 테이블에서 이전 단계에서 얻은 이름과 같은 row 의 개수를 반환한다.</li></ul><p>위 작업을 각각 함수로 만들었고 아래 형태의 타입이라고 생각해보자.</p><pre><code class="language-typescript">interface User {
  id: number;
  name: string;
  // ...
}

declare function getUser(id: number): Promise&lt;User&gt;;
declare function getNameField(user: User): string;
declare function toUppercase(str: string): string;
declare function getPostCount(name: string): Promise&lt;number&gt;;
</code></pre><p><code>getUser</code> 나 <code>getPostCount</code> 는 데이터베이스에서 가져오는 것이기에 대부분 ORM 라이브러리들은 <code>promise</code> 를 반환할 것이다.
각 단계를 함수로 만들었고 이제 함수형 패러다임에서 주로 사용하는 합성을 하려고 한다.</p><h2>함수의 합성</h2><p>먼저 수학에서 이야기하는 합성을 소개해보면</p><blockquote><p>한 함수의 공역이 다른 함수의 정의역과 일치하는 경우, 두 함수를 이어 하나의 함수로 만드는 연산이다.</p></blockquote><p><img src="./compose.png" alt="compose"/></p><p>수학에서 이야기하는 정의역과 공역을 프로그래밍 언어에서 함수의 파라미터와 반환 타입으로 생각해볼 수 있다.
즉 A 라는 함수의 반환 타입이 B 라는 함수의 파라미터와 일치하면 두 함수를 합성한 새로운 함수를 만들 수 있다.</p><pre><code class="language-typescript">declare function A(id: number): string;
declare function B(user: string): boolean;

function compose(id: number) {
  return B(A(id));
}
</code></pre><p>위 성질을 이용해 이전 단계에서 나눈 함수들을 합성하려고 해보면 바로 문제가 발생한다.
<code>getUser</code> 함수는 <code>Promise&lt;User&gt;</code> 를 반환하지만 <code>getNameField</code> 의 파라미터는 <code>User</code> 이기 때문이다.
<code>Promise&lt;User&gt;</code> 는 내부에 <code>User</code> 를 갖고있을지라도 어쨋든 <code>User</code> 타입과는 일치하지 않는다.</p><h2>Promise.prototype.then()</h2><p>합성을 하기위해 <code>getUser</code> 의 반환값을 <code>User</code> 로 바꾸거나 <code>getNameField</code> 의 파라미터를 <code>Promise&lt;User&gt;</code> 로 바꾸는 방법을 생각해볼 수 있다.</p><p>:::info
<code>async/await</code> 를 알고있다면 이 문제는 쉽게 해결된다는 것을 알고있지만 지금은 잠깐 무시하자.
:::</p><p>데이터베이스에 가여오는 작업은 비동기 작업이기에 promise 를 제거하기에는 어렵고
<code>getNameField</code> 의 파라미터를 <code>Promise&lt;User&gt;</code> 로 변경하면 안에있는 User 를 가져와서 name 을 꺼내는 로직을 작성할 수 없게된다.
이와 같은 문제의 해결방안으로 promise 의 then 메소드가 있다.</p><pre><code class="language-typescript">const userNamePromise = getUser(100).then((user) =&gt; getNameField(user)); // Promise&lt;string&gt;;
</code></pre><p>then 메소드는 함수를 파라미터로 받고 promise 의 내부값을 해당 함수의 파라미터로 전달하고 그 반환값을 새로운 promise 로 감싼다.
따라서 위 코드의 반환값은 <code>Promise&lt;string&gt;</code> 가 된다.
<code>string</code> 이 아닌 <code>Promise&lt;string&gt;</code> 가 되는 이유는 then 메소드는 <strong>주어진 비동기 작업이 성공적으로 끝난다면 그 값을 then 파라미터로 받은 함수로 넘겨주겠다는 새로운 약속</strong>을 만드는 역할을 하기 때문이다.
then 메소드가 promise 를 계속 반환하는 덕분에 계속해서 then 을 이용해 다음 함수를 넣어줄 수 있다.</p><pre><code class="language-typescript">const postCountPromise = getUser(100)
  .then((user) =&gt; getNameField(user))
  .then((name) =&gt; toUppercase(name))
  .then((name) =&gt; getPostCount(name));
</code></pre><p>함수형 프로그래밍에 익숙한 사람이라면 위 코드를 아래와 같은 <code>pointfree</code> 방식으로 작성하기도 한다.</p><pre><code class="language-typescript">const postCountPromise = getUser(100)
  .then(getNameField)
  .then(toUppercase)
  .then(getPostCount); // Promise&lt;number&gt;;
</code></pre><h2>Flatten</h2><p>이전 코드의 마지막 부분을 살펴보면 이상한 점이 있다.
<code>getPostCount</code> 는 <code>Promise&lt;number&gt;</code> 를 반환하고 then 메소드는 주어진 함수의 반환값을 다시 promise 로 감싼다고 했으니 최종 결과는 <code>Promise&lt;Promise&lt;number&gt;&gt;</code> 가 될거라는 생각이 든다.
하지만 결과가 <code>Promise&lt;number&gt;</code> 가 되는 이유는 then 메소드가 주어진 함수가 promise 를 반환하면 평탄화 과정을 거치기 때문이다.
배열의 경우에도 이와 비슷하게 <code>flatMap</code> 이 있어서 파라미터로 주어진 함수가 배열을 반환해도 기존 차원이 그대로 유지된다.</p><pre><code class="language-typescript">const arrA = [1, 2, 3, 4, 5];
arrA.map((v) =&gt; [v + 1]); // [[2], [3], [4], [5], [6]]
arrA.flatMap((v) =&gt; [v + 1]); // [2, 3, 4, 5, 6]
</code></pre><h2>마무리</h2><p>지금까지 <code>Promise&lt;User&gt;</code> 를 반환하는 함수로 시작해서 여러 다른 함수를 거쳐 최종 <code>Promise&lt;number&gt;</code> 를 만드는 과정을 살펴보았다.
보통 nodejs 환경에서 하나의 파라미터와 하나의 값을 반환하는 함수를 만든다면 내부 로직에 비동기 작업의 여부에 따라 아래 형태 중 하나가 될것이다.</p><pre><code class="language-typescript">declare function syncFunc&lt;A, B&gt;(a: A): B;
declare function asyncFunc&lt;A, B&gt;(a: A): Promise&lt;B&gt;;
</code></pre><p>모든 함수가 <code>syncFunc</code> 형태라면 쉽게 합성이 가능하지만 하나라도 <code>asyncFunc</code> 이 있다면 promise 의 then 과 같은 메소드를 사용해야 한다.
즉 then 은 위 두가지 형태를 가진 함수의 합성을 원활하게 해주는 역할을 한다.
이는 promise 가 monad 의 성질을 만족하기에 얻을 수 있는 장점이다.</p><p>지금까지 monad 의 정의보다 monad 를 통해 얻을 수 있는 장점에 대해 먼저 설명하였다.
그 이유는 <a href="https://xtendo.org/ko/monad#143">모나드 괴담</a> 이라고 불릴 정도로 monad 를 이해하기 어렵다는 인식이 있고,
nodejs 개발자에게 친숙한 promise 를 활용해 monad 를 어떻게 활용하는지에 대한 이해를 먼저 한다면 추후에 monad 를 이해하기 쉬울거라는 생각이 들었기 때문이다.</p><p>다음 글에서는 <code>async/await</code> 를 활용해 파라미터 개수가 2개 이상인 함수에 대한 처리와 monad 에 대한 조금 더 자세한 설명을 하려고 한다.</p><h2>참고자료</h2><ul><li>Promise.prototype.then(): <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/then">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/then</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Localstack 을 활용한 AWS SES 통합테스트]]></title>
            <link>https://jbl428.github.io/2021/10/31/local-stack</link>
            <guid>/2021/10/31/local-stack</guid>
            <pubDate>Sun, 31 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[localstack 은 AWS 인프라 시뮬레이터로 Lambda, S3, Dynamodb, Kinesis, SQS, SNS 같은 서비스를 로컬 환경에 올릴 수 있다.]]></description>
            <content:encoded><![CDATA[<p><code>localstack</code> 은 AWS 인프라 시뮬레이터로 Lambda, S3, Dynamodb, Kinesis, SQS, SNS 같은 서비스를 로컬 환경에 올릴 수 있다.
이번 글은 이메일 발송 서비스인 <code>SES</code> 를 테스트 해보기 위한 설정과정을 기술하고자 한다.</p><blockquote><p>과정에 대한 모든 코드는 다음 URL을 참조한다.
<a href="https://github.com/jbl428/study-note/tree/master/localstack">https://github.com/jbl428/study-note/tree/master/localstack</a></p></blockquote><h2>환경</h2><p><code>node.js</code> 환경에서 <code>jest</code> 를 활용해 테스트 하였으며 <code>testcontainers</code> 라이브러리를 활용하였다.</p><blockquote><p>본 글을 작성하는 시점에서는 <code>SES API</code> 버전이 v2 가 나왔지만 <code>localstack</code> 이 지원하지 않아 v1 을 이용하였다.</p></blockquote><p><code>localstack</code> 의 경우 예전 버전은 각 서비스 별로 접속 endpoint 가 달랐지만 지금은 하나로 통합되었다.
유료버전이 따로 있으며 더 많은 기능을 지원한다고 한다. <code>SES</code> 서비스는 무료버전도 지원한다.</p><h2>testcontainers</h2><p><code>testcontainers</code> 는 도커 컨테이너를 활용해 테스트를 위한 환경을 만들어주는 라이브러리로 코드로 컨테이너를 실행 및 종료 할 수 있는거라 보면된다.
여러 프로그래밍 언어를 지원하며 가장 많은 star 를 보유한 언어는 자바이다.
그래서 localstack 용 모듈을 따로 지원해 편하게 쓸 수 있지만 node.js 용은 없기에 번거로운 과정을 거쳐야한다.</p><pre><code class="language-sh">yarn add -D testcontainers
</code></pre><p>보통 테스트 파일의 beforeAll 에 컨테이너 실행 로직을 넣어준다.</p><pre><code class="language-ts">import { GenericContainer, StartedTestContainer, Wait } from &#x27;testcontainers&#x27;;

describe(&#x27;localstack test&#x27;, () =&gt; {
  let localstackPort: number;
  let container: StartedTestContainer;

  beforeAll(async () =&gt; {
    container = await new GenericContainer(&#x27;localstack/localstack&#x27;)
      .withExposedPorts(4566)
      .withEnv(&#x27;SERVICES&#x27;, &#x27;ses&#x27;)
      .withWaitStrategy(Wait.forLogMessage(&#x27;Execution of &quot;preload_services&quot;&#x27;))
      .start();

    localstackPort = container.getMappedPort(4566);
  });

  afterAll(() =&gt; container.stop());

  // ...테스트 케이스

};
</code></pre><pre><code class="language-ts">container = await new GenericContainer(&quot;localstack/localstack&quot;);
</code></pre><p>GenericContainer 클래스의 생성자 파라미터로 실행을 원하는 컨테이너 이미지 이름을 넣어준다.</p><pre><code class="language-ts">    .withExposedPorts(4566)
</code></pre><p>컨테이너 내부의 특정 포트를 외부의 사용하지 않는 임의의 포트로 expose 해주는 역할을 한다.
위의 경우 컨테이너의 4566 포트를 외부로 노출시키며 로컬의 미사용 포트번호 중에 임의로 설정해준다.
이를 통해 여러 컨테이너를 동시에 실행시켜도 각각 다른 포트로 노출되기에 테스트를 병렬로 실행하면서 각 테스트 케이스간의 독립성을 지켜준다.</p><pre><code class="language-ts">    .withWaitStrategy(Wait.forLogMessage(&#x27;Execution of &quot;preload_services&quot;&#x27;))
</code></pre><p>특정 컨테이너는 실행이 완료되도 이후에 초기 세팅과정이 있기 때문에 해당 컨테이너를 온전히 사용하기 까지 기다려야 하는 경우가 발생한다.
따라서 withWaitStrategy 를 통해 어떤 조건에 해당할 때까지 기다릴 것인지 설정할 수 있다.
위의 경우는 컨테이너 로그 메세지 중에 Execution of &quot;preload_services&quot; 문구가 포착될 때까지 기다린다는 설정이다.
wait strategy 는 여러가지가 있으며 각 항목은 아래 문서를 참조한다.</p><p><a href="https://www.testcontainers.org/features/startup_and_waits/">https://www.testcontainers.org/features/startup_and_waits/</a></p><pre><code class="language-ts">localstackPort = container.getMappedPort(4566);
</code></pre><p>withExposedPorts 를 통해 노출한 포트를 알아낸 후 localstackPort 변수에 할당하며 이를 테스트 케이스에서 활용한다.</p><pre><code class="language-ts">afterAll(() =&gt; container.stop());
</code></pre><p>테스트가 종료되면 컨테이너를 종료하는 코드이며 사실 testcontainer 는 종료로직을 넣지 않아도 일정 시간동안 활동이 없으면 자동으로 컨테이너를 종료시켜주는 기능이 있다.
ryuk container 라고 불리는 컨테이너가 그 역할을 한다.</p><p><a href="https://hub.docker.com/r/testcontainers/ryuk">https://hub.docker.com/r/testcontainers/ryuk</a></p><pre><code class="language-ts">const client = new SESClient({
  region: &quot;local&quot;,
  endpoint: `http://localhost:${localstackPort}`, // localstackPort 으로 포트설정
  credentials: {
    accessKeyId: &quot;test&quot;,
    secretAccessKey: &quot;test&quot;,
  },
});
</code></pre><p>운영 aws 을 사용하려면 <code>accessKeyId</code> 나 <code>secretAccessKey</code> 같은 접속정보를 제공해야 하는데 localstack 에서는 빈 문자열이 아닌 임의의 문자열을 지정해도 정상동작함을 확인했다.
하지만 문서를 보니 S3를 이용하는 경우 test 로 설정하는 것을 권장하기에 따라서 지정한다.</p><p>SES 경우 인증된 메일 주소로만 발송주소를 설정할 수 있고 localstack 도 똑같이 메일발송 api 호출 전에 인증 api 를 사용해 메일주소를 등록해야 한다.</p><pre><code class="language-ts">const command = new VerifyEmailAddressCommand({
  EmailAddress: &quot;from@inflab.com&quot;,
});
await client.send(command);
</code></pre><p>이후에 sdk 에 요구하는 스팩에 맞게 발송로직을 추가한다.</p><pre><code class="language-ts">const sendCommand = new SendEmailCommand({
  // 메일 전송 옵션들...
});
await client.send(sendCommand);
</code></pre><h2>참고자료</h2><ul><li>testcontainers: <a href="https://www.testcontainers.org">https://www.testcontainers.org</a></li><li>localstack: <a href="https://github.com/localstack/localstack">https://github.com/localstack/localstack</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[함수형 프로그래밍 관련 자료]]></title>
            <link>https://jbl428.github.io/2021/10/21/functional-programming-material</link>
            <guid>/2021/10/21/functional-programming-material</guid>
            <pubDate>Thu, 21 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[그동안 함수형 프로그래밍에 대한 공부를 하면서 보았던 자료들을 이곳에 기록하려고 한다.]]></description>
            <content:encoded><![CDATA[<p>그동안 함수형 프로그래밍에 대한 공부를 하면서 보았던 자료들을 이곳에 기록하려고 한다.</p><h2>서적</h2><h3>함수형 사고 (Neal Ford)</h3><p>메모이제이션 개념에 대해 처음 알게된 책이다.</p><h3>함수형 자바스크립트 (Luis Atencio)</h3><p>자바스크립트로 하는 함수형 프로그래밍 책으로 읽은것은 기억나는데 딱히 기억에 남는 내용은 없었다.</p><h3>Grokking Simplicity Taming complex software with functional thinking (Eric Normand)</h3><p>프로그램을 Action, Calculation, Data 로 나누어 생각하고 함수형 프로그래밍을 전염성이 강하고 테스트 하기 힘든 Action 을 Calculation 으로 만드는 패러다임으로 설명하고 있다.
초반부는 흥미롭게 읽었지만 이후에는 이미 익숙한 내용이 많아서 끝까지 읽지는 않았다.</p><h3>Learning Functional Programming in Go (Lex Sheehan)</h3><p>고언어로 함수형 프로그래밍을 어떻게 할 수 있는지 알 수 있는 책.
고언어는 함수를 <code>type</code> 명령어로 새로운 타입으로 만들면 함수의 메소드라는 독특한 성질을 만들 수 있는데 이를 활용해서 함수 체이닝을 구현한게 참신했다.
채널을 활용해 pipeline을 만든는 코드도 놀라워 직접 구현해보기도 하였다.</p><blockquote><p><a href="https://github.com/jbl428/study-note/tree/master/go-pipeline">https://github.com/jbl428/study-note/tree/master/go-pipeline</a></p></blockquote><h3>스칼라로 배우는 함수형 프로그래밍 (Paul Chiusano and Runar Bjarnason)</h3><p>모나드를 이용해 side effect 있는 프로그램을 순수한 함수들의 합성으로 만들 수 있는지 감을 잡게 해준 책이다.
연습문제 중에 상태모나드를 활용해야 하는게 있었는데 풀면서 어려웠던 상태모나드를 이해할 수 있게되었다.
풀었던 문제와 답은 아래 링크에 있다.</p><blockquote><p><a href="https://github.com/jbl428/study-note/tree/master/haskell/candy-machine">https://github.com/jbl428/study-note/tree/master/haskell/candy-machine</a></p></blockquote><h2>영상</h2><h3>Monad란 무엇인가?</h3><p><a href="https://www.youtube.com/watch?v=jI4aMyqvpfQ">https://www.youtube.com/watch?v=jI4aMyqvpfQ</a></p><p>개인적으로 모나드에 대해 쉽게 설명했다고 느낀 영상이었다. <code>flatMap</code> 에 대한 개념을 익히는데 도움이 되었다.</p><h3>haskell rank</h3><p><a href="https://www.youtube.com/watch?v=h_D4P-KRNKs&amp;list=PLguYJK7ydFE4aS8fq4D6DqjF6qsysxTnx">https://www.youtube.com/watch?v=h_D4P-KRNKs&amp;list=PLguYJK7ydFE4aS8fq4D6DqjF6qsysxTnx</a></p><p><a href="https://www.hackerrank.com/">https://www.hackerrank.com/</a> 에서 제공하는 프로그래밍 문제를 하스켈을 이용해 풀이하는 영상이 있다.
명령형 언어로 구현하면 길어질 수 있는 코드를 하스켈로 간결하게 만드는 과정이 신기했다.
그리고 유투버가 <code>emacs</code> 를 정말 잘 사용하는데 한 번 시청하길 권해본다.</p><h3>JSON Parser 100% From Scratch in Haskell (only 111 lines)</h3><p><a href="https://www.youtube.com/watch?v=N9RUqGYuGfw">https://www.youtube.com/watch?v=N9RUqGYuGfw</a></p><p>위 영상을 만든 유튜버의 또 다른 영상으로 하스켈로 <code>JSON</code> 파서를 만드는 과정을 담고있다.
모나드를 실제로 어떻게 활용하는지 알 수 있었던 좋은 영상이었고 하스켈을 꼭 마스터 해보고 싶어진 계기가 되었다.</p><h2>강의</h2><h3>함수형 프로그래밍과 JavaScript ES6+</h3><p><a href="https://www.inflearn.com/course/functional-es6/dashboard">https://www.inflearn.com/course/functional-es6/dashboard</a></p><p>유인동님의 함수형 프로그래밍 강의로 ES6 이터레이터를 활용해 <code>fxjs</code> 라이브러리의 핵심 함수를 구현하는 과정을 담고있다.
개인적으로 자바스크립트로 지연평가를 구현했다는게 가장 놀라웠다.
그리고 <code>go</code> 함수에 파라미터로 들어가는 함수가 promise 를 반환하면 적절히 다음 함수에 promise 안의 값을 전달해 주도록 구현한 아이디어가 매우 좋았다.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Docusaurus 에 utterances 연동]]></title>
            <link>https://jbl428.github.io/2021/10/19/utterances</link>
            <guid>/2021/10/19/utterances</guid>
            <pubDate>Tue, 19 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[utterances 는 GitHub 이슈 를 이용해서 원하는 사이트의 댓글 기능을 만들어주는 서비스이다.]]></description>
            <content:encoded><![CDATA[<p><a href="https://utteranc.es/">utterances</a> 는 <code>GitHub 이슈</code> 를 이용해서 원하는 사이트의 댓글 기능을 만들어주는 서비스이다.
따라서 github 계정이 존재해야 댓글 작성이 가능하지만 개발에 관련 글을 작성할 예정이라 큰 문제는 아니었다.
만약 다른 소셜 로그인도 지원하고 싶다면 <a href="https://disqus.com/">disqus</a> 같은 서비스를 사용하면 된다.</p><p><code>docusaurus</code> 에 <code>utterances</code> 를 연동하는 방법에 관한 문서를 검색해보았는데 딱 하나 존재했다.</p><ul><li><a href="https://younho9.dev/docusaurus-manage-docs-2">https://younho9.dev/docusaurus-manage-docs-2</a></li></ul><p>해당 글을 참조해서 연동하였지만 모든 부분을 그대로 따라하지는 않았다.
테마에 따라 <code>utterances</code> 의 테마도 똑같이 수정하는 코드는 많은 도움이 되었다.</p><h2>utterances 사전 설정</h2><p>utterances 연동하려면 github 저장소가 public 이어야 한다.
저장소가 <a href="https://github.com/apps/utterances">utterances app</a> 을 사용하도록 설정해야 한다.
링크를 누른 후 <code>Configure</code> 를 누른 후 github 로그인 후 아래 화면처럼 저장소를 선택한고 <code>Save</code> 를 누른다.</p><p><img src="./utterances-app.png" alt="utterances-app"/></p><h2>docusaurus 테마 컴포넌트 수정</h2><p>검색한 글에서는 <code>swizzle</code> 명령어를 통해서 <code>docusaurus</code> 가 내부적으로 사용하는 컴포넌트를 직접 수정해서 사용했다.
하지만 <a href="https://docusaurus.io/ko/docs/using-themes#swizzling-theme-components">공식문서</a> 를 보면 권장하는 방법은 아니다.
해당 컴포넌트가 버전이 올라가면 변경될 가능성이 있기 때문이다.
따라서 해당 글의 아래 부분에 있는 <a href="https://docusaurus.io/ko/docs/using-themes#wrapping-theme-components">테마 컴포넌트 감싸기</a> 기능을 사용했다.
그러면 기존 컴포넌트의 소스는 건들지 않고 utterances 를 위한 로직만 추가하면 되기에 더 안전하다.
테마에 따라 utterances 의 테마도 바뀌는 로직을 포함한 전체 코드는 아래와 같다.</p><p>:::info
<code>&lt;사용자이름&gt;</code> 부분을 적절히 수정한다.
:::</p><pre><code class="language-jsx" metastring="title=&quot;src/theme/BlogPostItem.tsx&quot;" title="&quot;src/theme/BlogPostItem.tsx&quot;">import React, { useEffect, useRef } from &quot;react&quot;;
import OriginalBlogPostItem from &quot;@theme-original/BlogPostItem&quot;;
import useThemeContext from &quot;@theme/hooks/useThemeContext&quot;;

const utterancesSelector = &quot;iframe.utterances-frame&quot;;

function BlogPostItem(props) {
  const { isDarkTheme } = useThemeContext();
  const utterancesTheme = isDarkTheme ? &quot;github-dark&quot; : &quot;github-light&quot;;
  const containerRef = useRef(null);

  useEffect(() =&gt; {
    if (!props.isBlogPostPage) return;

    const utterancesEl = containerRef.current.querySelector(utterancesSelector);

    const createUtterancesEl = () =&gt; {
      const script = document.createElement(&quot;script&quot;);

      script.src = &quot;https://utteranc.es/client.js&quot;;
      script.setAttribute(&quot;repo&quot;, &quot;&lt;사용자이름&gt;/&lt;사용자이름&gt;.github.io&quot;);
      script.setAttribute(&quot;issue-term&quot;, &quot;pathname&quot;);
      script.setAttribute(&quot;label&quot;, &quot;comment&quot;);
      script.setAttribute(&quot;theme&quot;, utterancesTheme);
      script.crossOrigin = &quot;anonymous&quot;;
      script.async = true;

      containerRef.current.appendChild(script);
    };

    const postThemeMessage = () =&gt; {
      const message = {
        type: &quot;set-theme&quot;,
        theme: utterancesTheme,
      };

      utterancesEl.contentWindow.postMessage(message, &quot;https://utteranc.es&quot;);
    };

    utterancesEl ? postThemeMessage() : createUtterancesEl();
  }, [utterancesTheme]);

  return (
    &lt;&gt;
      &lt;OriginalBlogPostItem {...props} /&gt;
      {props.isBlogPostPage &amp;&amp; &lt;div ref={containerRef} /&gt;}
    &lt;/&gt;
  );
}

export default BlogPostItem;
</code></pre><p><code>src/theme/</code> 경로 밑에 <code>&lt;컴포넌트 이름&gt;.tsx</code> 파일을 생성하면 해당 컴포넌트를 커스텀 할 수 있다.
<code>@theme-original/&lt;컴포넌트&gt;</code> 를 import 하면 원본 컴포넌트를 가져올 수 있고 해당 컴포넌트에 utterances 관련 내용만 추가하면 된다.</p><pre><code class="language-jsx" metastring="{2,7-11} title=&quot;src/theme/BlogPostItem.tsx&quot;" title="&quot;src/theme/BlogPostItem.tsx&quot;">import React, { useEffect, useRef } from &quot;react&quot;;
import OriginalBlogPostItem from &quot;@theme-original/BlogPostItem&quot;; // 원본 컴포넌트 가져오기
import useThemeContext from &quot;@theme/hooks/useThemeContext&quot;;

  ...

  return (
    &lt;&gt;
      &lt;OriginalBlogPostItem {...props} /&gt;
      {props.isBlogPostPage &amp;&amp; &lt;div ref={containerRef} /&gt;} // 댓글 화면 추가
    &lt;/&gt;
</code></pre><p>이제 댓글 기능이 제대로 되는지 확인해본다.</p><h2>공식문서를 읽자</h2><p>이전 글에서 말한 내용이지만 블로그 글은 참조용으로만 사용하고 공식문서를 메인으로 활용하는게 중요하다고 생각한다.
만약 블로그 글만 참조했다면 <code>테마 컴포넌트 감싸기</code> 라는 기능을 몰랐을테고 더 좋은 연동방법을 적용하지 못했을것이다.
이 글도 누군가에게 참고용으로만 사용되기를 바라며 더 좋은 방법을 찾아보고 적용하셨으면 좋겠다.</p><h2>참고자료</h2><ul><li>Docusaurus로 문서 관리하기 - 2: <a href="https://younho9.dev/docusaurus-manage-docs-2">https://younho9.dev/docusaurus-manage-docs-2</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Docusaurus 를 이용한 블로그 구축]]></title>
            <link>https://jbl428.github.io/2021/10/17/docusaurus-for-blog</link>
            <guid>/2021/10/17/docusaurus-for-blog</guid>
            <pubDate>Sun, 17 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[기술 블로그를 위해 어떤 플랫폼을 사용할지 고민하다가 직장 동료가 Docusaurus 를 추천해주었다.]]></description>
            <content:encoded><![CDATA[<p>기술 블로그를 위해 어떤 플랫폼을 사용할지 고민하다가 직장 동료가 <code>Docusaurus</code> 를 추천해주었다.
다크모드를 지원하고 크게 커스텀하지 않아도 쓸만한 블로그를 만들 수 있을거같았다.
그래서 첫 블로그 글로 구축한 내용을 공유하려고 한다.</p><p>개인적으로 기술관련 환경을 세팅할 때에는 블로그 보다는 공식문서를 활용한다.
블로그 글은 작성 당시에는 맞는 설치방법이었지만 시간이 지나 버전이 올라가는 경우 그대로 따라하면 제대로 동작하지 않는 경우가 많기 때문이다.
그렇기에 이 글을 그대로 따라하여 구축하기 보다 참고용으로 활용하고 공식문서를 주로 이용하기를 권장한다.</p><h2>환경</h2><p>블로그를 위해 사용한 기술과 각 버전은 다음과 같다.</p><ul><li>Docusaurus (with typescript): 2.0.0-beta.7</li><li>GitHub Page</li><li>GitHub Action</li></ul><p>관련 저장소는 아래 링크를 참조한다.</p><p><a href="https://github.com/jbl428/jbl428.github.io">https://github.com/jbl428/jbl428.github.io</a></p><h2>GitHub 저장소 생성</h2><p><code>GitHub Page</code> 는 깃허브에서 제공하는 무료 호스팅 서비스이다. 블로그나 포트폴리오 같은 정적 사이트로 주로 사용된다.
깃허브에 들어가서 저장소를 생성하는데 이름은 <code>&lt;사용자이름&gt;.github.io</code> 형태로 설정해주고 나머지 옵션은 상황에 따라 적절히 설정한다.
이후 해당 저장소를 clone 한다.</p><pre><code class="language-shell">git clone https://github.com/&lt;사용자이름&gt;/&lt;사용자이름&gt;.github.io.git
</code></pre><h2>Docusaurus 설치</h2><p>저장소 루트 디렉토리로 이동한 다음 아래 명령어를 수행한다.</p><pre><code class="language-shell">npm init docusaurus@latest temp classic --typescript
</code></pre><p><code>temp</code> 디렉토리에 docusaurus 관련 파일이 들어가는데 저장소 루트로 모두 이동한다.</p><pre><code class="language-shell">mv temp/* .
mv temp/.* .
</code></pre><h2>기본설정</h2><p><code>docusaurus.config.js</code> 파일에는 <code>Docusaurus</code> 에 대한 설정이 들어있다.
각 항목에 대한 설명은 <a href="https://docusaurus.io/ko/docs/docusaurus.config.js">문서</a> 를 참조한다.</p><pre><code class="language-jsx" metastring="{3-11} title=&quot;docusaurus.config.js&quot;" title="&quot;docusaurus.config.js&quot;">module.exports = {
  // ...
  title: &quot;사이트 제목&quot;,
  tagline: &quot;사이트 설명&quot;,
  url: &quot;https://&lt;사용자이름&gt;.github.io&quot;,
  baseUrl: &quot;/&quot;,
  onBrokenLinks: &quot;throw&quot;,
  onBrokenMarkdownLinks: &quot;warn&quot;,
  favicon: &quot;img/favicon.ico&quot;,
  organizationName: &quot;&lt;사용자이름&gt;&quot;,
  projectName: &quot;&lt;사용자이름&gt;.github.io&quot;,
  // ...
};
</code></pre><h2>배포 설정</h2><p><code>GitHub Action</code> 을 활용해서 <code>main</code> 브랜치에 푸시가 일어나면 빌드를 수행하고 <code>gh-pages</code> 브랜치로 결과를 푸시하는 설정을 해준다.
<a href="https://docusaurus.io/ko/docs/deployment#triggering-deployment-with-github-actions">링크</a> 를 참조해서 5번 단계까지 작업을 해준다.
마지막 6번 단계인 <code>workflow</code> 파일을 만드는 부분만 아래처럼 해준다.</p><p>:::info
<code>&lt;이메일&gt;</code> 과 <code>&lt;이름&gt;</code> 부분을 적절히 수정하도록 한다.
:::</p><pre><code class="language-yaml" metastring="title=&quot;.github/workflows/blog.yml&quot;" title="&quot;.github/workflows/blog.yml&quot;">name: blog

on:
  push:
    branches: [main]

jobs:
  gh-release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v1
      - uses: actions/setup-node@v1
        with:
          node-version: &quot;12.x&quot;
      - uses: webfactory/ssh-agent@v0.5.0
        with:
          ssh-private-key: ${{ secrets.GH_PAGES_DEPLOY }}
      - name: Release to GitHub Pages
        env:
          USE_SSH: true
          GIT_USER: git
          DEPLOYMENT_BRANCH: gh-pages
          CURRENT_BRANCH: main
        run: |
          git config --global user.email &quot;&lt;이메일&gt;&quot;
          git config --global user.name &quot;&lt;이름&gt;&quot;
          if [ -e yarn.lock ]; then
            yarn install --frozen-lockfile
          elif [ -e package-lock.json ]; then
            npm ci
          else
            npm i
          fi
          npm run deploy
</code></pre><h2>보관소 페이지 추가</h2><p>처음에는 <a href="https://blog.johnnyreilly.com/blog-archive">John Reilly archive</a> 처럼 모든 게시글을 연도별로 정리한 페이지를 추가하고자 이분의 저장소 코드를 복사해서 사용했다.
하지만 공식문서를 보니 이미 위와 같은 기능이 <code>Docusaurus</code> 에 반영된 것을 확인하였다.
아래처럼 적절한 경로에 값을 추가하면된다.</p><pre><code class="language-jsx" metastring="{7,15} title=&quot;docusaurus.config.js&quot;" title="&quot;docusaurus.config.js&quot;">module.exports = {
  // ...
  presets: [
    [
      {
        blog: {
          archiveBasePath: &quot;archive&quot;,
        },
      },
    ],
  ],
  // ...
  themeConfig: {
    navbar: {
      items: [{ to: &quot;/archive&quot;, label: &quot;Archive&quot;, position: &quot;left&quot; }],
    },
  },
  // ...
};
</code></pre><h2>i18n 설정</h2><p>기본 언어 설정을 한글로 하기위해 로케일 설정을 해준다.</p><pre><code class="language-jsx" metastring="{3-6} title=&quot;docusaurus.config.js&quot;" title="&quot;docusaurus.config.js&quot;">module.exports = {
  // ...
  i18n: {
    defaultLocale: &quot;ko&quot;,
    locales: [&quot;ko&quot;],
  },
  // ...
};
</code></pre><p>그리고 아래 명령어를 수행하면 <code>i18n</code> 디렉토리 밑에 각종 레이블에 대한 json 파일이 생성된다.</p><pre><code class="language-shell">yarn docusaurus write-translations
</code></pre><p>내용을 살펴보면 한글로 번역이 안된 부분이 있는데 적절히 수정해준다.</p><pre><code class="language-json" metastring="title=&quot;i18n/ko/code.json&quot;" title="&quot;i18n/ko/code.json&quot;">  &quot;theme.blog.archive.title&quot;: {
    &quot;message&quot;: &quot;보관소&quot;,
    &quot;description&quot;: &quot;The page &amp; hero title of the blog archive page&quot;
  },
  &quot;theme.blog.archive.description&quot;: {
    &quot;message&quot;: &quot;모든 게시물&quot;,
    &quot;description&quot;: &quot;The page &amp; hero description of the blog archive page&quot;
  }
</code></pre><pre><code class="language-json" metastring="title=&quot;i18n/ko/docusaurus-plugin-content-blog/options.json&quot;" title="&quot;i18n/ko/docusaurus-plugin-content-blog/options.json&quot;">  &quot;sidebar.title&quot;: {
    &quot;message&quot;: &quot;최근 게시물&quot;,
    &quot;description&quot;: &quot;The label for the left sidebar&quot;
  }
</code></pre><h2>GitHub Page 로 사용할 브랜치 설정</h2><p>저장소의 어떤 브랜치의 특정 경로를 웹페이지로 사용할 것인지 설정해야한다.
배포설정을 통해 <code>gh-pages</code> 브랜치의 루트에 정적파일이 생성되므로 아래 화면처럼 설정한다.</p><p><img src="./github-setting.png" alt="github-setting"/></p><p><img src="./github-page-setting.png" alt="github-page-setting"/></p><h2>마지막</h2><p>이제 <code>https://&lt;사용자이름&gt;.github.io</code> 페이지에 접속하면 만든 블로그를 확인할 수 있다.
하지만 댓글을 작성할 수 있는 기능은 없는데 추후 게시글로 작성하려고 한다.</p><h2>참고자료</h2><ul><li>Docusaurus 공식문서: <a href="https://docusaurus.io/ko/docs">https://docusaurus.io/ko/docs</a></li></ul>]]></content:encoded>
        </item>
    </channel>
</rss>